{"ast":null,"code":"/*!\n * resource-loader - v3.0.1\n * https://github.com/pixijs/pixi-sound\n * Compiled Tue, 02 Jul 2019 14:06:18 UTC\n *\n * resource-loader is licensed under the MIT license.\n * http://www.opensource.org/licenses/mit-license\n */\nimport parseUri from 'parse-uri';\nimport Signal from 'mini-signals';\n/**\n * Smaller version of the async library constructs.\n *\n * @namespace async\n */\n\n/**\n * Noop function\n *\n * @ignore\n * @function\n * @memberof async\n */\n\nfunction _noop() {}\n/* empty */\n\n/**\n * Iterates an array in series.\n *\n * @memberof async\n * @function eachSeries\n * @param {Array.<*>} array - Array to iterate.\n * @param {function} iterator - Function to call for each element.\n * @param {function} callback - Function to call when done, or on error.\n * @param {boolean} [deferNext=false] - Break synchronous each loop by calling next with a setTimeout of 1.\n */\n\n\nfunction eachSeries(array, iterator, callback, deferNext) {\n  var i = 0;\n  var len = array.length;\n\n  (function next(err) {\n    if (err || i === len) {\n      if (callback) {\n        callback(err);\n      }\n\n      return;\n    }\n\n    if (deferNext) {\n      setTimeout(function () {\n        iterator(array[i++], next);\n      }, 1);\n    } else {\n      iterator(array[i++], next);\n    }\n  })();\n}\n/**\n * Ensures a function is only called once.\n *\n * @ignore\n * @memberof async\n * @param {function} fn - The function to wrap.\n * @return {function} The wrapping function.\n */\n\n\nfunction onlyOnce(fn) {\n  return function onceWrapper() {\n    if (fn === null) {\n      throw new Error('Callback was already called.');\n    }\n\n    var callFn = fn;\n    fn = null;\n    callFn.apply(this, arguments);\n  };\n}\n/**\n * Async queue implementation,\n *\n * @memberof async\n * @function queue\n * @param {function} worker - The worker function to call for each task.\n * @param {number} concurrency - How many workers to run in parrallel.\n * @return {*} The async queue object.\n */\n\n\nfunction queue(worker, concurrency) {\n  if (concurrency == null) {\n    // eslint-disable-line no-eq-null,eqeqeq\n    concurrency = 1;\n  } else if (concurrency === 0) {\n    throw new Error('Concurrency must not be zero');\n  }\n\n  var workers = 0;\n  var q = {\n    _tasks: [],\n    concurrency: concurrency,\n    saturated: _noop,\n    unsaturated: _noop,\n    buffer: concurrency / 4,\n    empty: _noop,\n    drain: _noop,\n    error: _noop,\n    started: false,\n    paused: false,\n    push: function push(data, callback) {\n      _insert(data, false, callback);\n    },\n    kill: function kill() {\n      workers = 0;\n      q.drain = _noop;\n      q.started = false;\n      q._tasks = [];\n    },\n    unshift: function unshift(data, callback) {\n      _insert(data, true, callback);\n    },\n    process: function process() {\n      while (!q.paused && workers < q.concurrency && q._tasks.length) {\n        var task = q._tasks.shift();\n\n        if (q._tasks.length === 0) {\n          q.empty();\n        }\n\n        workers += 1;\n\n        if (workers === q.concurrency) {\n          q.saturated();\n        }\n\n        worker(task.data, onlyOnce(_next(task)));\n      }\n    },\n    length: function length() {\n      return q._tasks.length;\n    },\n    running: function running() {\n      return workers;\n    },\n    idle: function idle() {\n      return q._tasks.length + workers === 0;\n    },\n    pause: function pause() {\n      if (q.paused === true) {\n        return;\n      }\n\n      q.paused = true;\n    },\n    resume: function resume() {\n      if (q.paused === false) {\n        return;\n      }\n\n      q.paused = false; // Need to call q.process once per concurrent\n      // worker to preserve full concurrency after pause\n\n      for (var w = 1; w <= q.concurrency; w++) {\n        q.process();\n      }\n    }\n  };\n\n  function _insert(data, insertAtFront, callback) {\n    if (callback != null && typeof callback !== 'function') {\n      // eslint-disable-line no-eq-null,eqeqeq\n      throw new Error('task callback must be a function');\n    }\n\n    q.started = true;\n\n    if (data == null && q.idle()) {\n      // eslint-disable-line no-eq-null,eqeqeq\n      // call drain immediately if there are no tasks\n      setTimeout(function () {\n        return q.drain();\n      }, 1);\n      return;\n    }\n\n    var item = {\n      data: data,\n      callback: typeof callback === 'function' ? callback : _noop\n    };\n\n    if (insertAtFront) {\n      q._tasks.unshift(item);\n    } else {\n      q._tasks.push(item);\n    }\n\n    setTimeout(function () {\n      return q.process();\n    }, 1);\n  }\n\n  function _next(task) {\n    return function next() {\n      workers -= 1;\n      task.callback.apply(task, arguments);\n\n      if (arguments[0] != null) {\n        // eslint-disable-line no-eq-null,eqeqeq\n        q.error(arguments[0], task.data);\n      }\n\n      if (workers <= q.concurrency - q.buffer) {\n        q.unsaturated();\n      }\n\n      if (q.idle()) {\n        q.drain();\n      }\n\n      q.process();\n    };\n  }\n\n  return q;\n}\n\nvar async = {\n  eachSeries: eachSeries,\n  queue: queue\n}; // a simple in-memory cache for resources\n\nvar cache = {};\n/**\n * A simple in-memory cache for resource.\n *\n * @memberof middleware\n * @function caching\n * @example\n * import { Loader, middleware } from 'resource-loader';\n * const loader = new Loader();\n * loader.use(middleware.caching);\n * @param {Resource} resource - Current Resource\n * @param {function} next - Callback when complete\n */\n\nfunction caching(resource, next) {\n  var _this = this; // if cached, then set data and complete the resource\n\n\n  if (cache[resource.url]) {\n    resource.data = cache[resource.url];\n    resource.complete(); // marks resource load complete and stops processing before middlewares\n  } // if not cached, wait for complete and store it in the cache.\n  else {\n      resource.onComplete.once(function () {\n        return cache[_this.url] = _this.data;\n      });\n    }\n\n  next();\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nvar useXdr = !!(window.XDomainRequest && !('withCredentials' in new XMLHttpRequest()));\nvar tempAnchor = null; // some status constants\n\nvar STATUS_NONE = 0;\nvar STATUS_OK = 200;\nvar STATUS_EMPTY = 204;\nvar STATUS_IE_BUG_EMPTY = 1223;\nvar STATUS_TYPE_OK = 2; // noop\n\nfunction _noop$1() {}\n/* empty */\n\n/**\n * Manages the state and loading of a resource and all child resources.\n *\n * @class\n */\n\n\nvar Resource =\n/*#__PURE__*/\nfunction () {\n  /**\n   * Sets the load type to be used for a specific extension.\n   *\n   * @static\n   * @param {string} extname - The extension to set the type for, e.g. \"png\" or \"fnt\"\n   * @param {Resource.LOAD_TYPE} loadType - The load type to set it to.\n   */\n  Resource.setExtensionLoadType = function setExtensionLoadType(extname, loadType) {\n    setExtMap(Resource._loadTypeMap, extname, loadType);\n  }\n  /**\n   * Sets the load type to be used for a specific extension.\n   *\n   * @static\n   * @param {string} extname - The extension to set the type for, e.g. \"png\" or \"fnt\"\n   * @param {Resource.XHR_RESPONSE_TYPE} xhrType - The xhr type to set it to.\n   */\n  ;\n\n  Resource.setExtensionXhrType = function setExtensionXhrType(extname, xhrType) {\n    setExtMap(Resource._xhrTypeMap, extname, xhrType);\n  }\n  /**\n   * @param {string} name - The name of the resource to load.\n   * @param {string|string[]} url - The url for this resource, for audio/video loads you can pass\n   *      an array of sources.\n   * @param {object} [options] - The options for the load.\n   * @param {string|boolean} [options.crossOrigin] - Is this request cross-origin? Default is to\n   *      determine automatically.\n   * @param {number} [options.timeout=0] - A timeout in milliseconds for the load. If the load takes\n   *      longer than this time it is cancelled and the load is considered a failure. If this value is\n   *      set to `0` then there is no explicit timeout.\n   * @param {Resource.LOAD_TYPE} [options.loadType=Resource.LOAD_TYPE.XHR] - How should this resource\n   *      be loaded?\n   * @param {Resource.XHR_RESPONSE_TYPE} [options.xhrType=Resource.XHR_RESPONSE_TYPE.DEFAULT] - How\n   *      should the data being loaded be interpreted when using XHR?\n   * @param {Resource.IMetadata} [options.metadata] - Extra configuration for middleware and the Resource object.\n   */\n  ;\n\n  function Resource(name, url, options) {\n    if (typeof name !== 'string' || typeof url !== 'string') {\n      throw new Error('Both name and url are required for constructing a resource.');\n    }\n\n    options = options || {};\n    /**\n     * The state flags of this resource.\n     *\n     * @private\n     * @member {number}\n     */\n\n    this._flags = 0; // set data url flag, needs to be set early for some _determineX checks to work.\n\n    this._setFlag(Resource.STATUS_FLAGS.DATA_URL, url.indexOf('data:') === 0);\n    /**\n     * The name of this resource.\n     *\n     * @readonly\n     * @member {string}\n     */\n\n\n    this.name = name;\n    /**\n     * The url used to load this resource.\n     *\n     * @readonly\n     * @member {string}\n     */\n\n    this.url = url;\n    /**\n     * The extension used to load this resource.\n     *\n     * @readonly\n     * @member {string}\n     */\n\n    this.extension = this._getExtension();\n    /**\n     * The data that was loaded by the resource.\n     *\n     * @member {any}\n     */\n\n    this.data = null;\n    /**\n     * Is this request cross-origin? If unset, determined automatically.\n     *\n     * @member {string}\n     */\n\n    this.crossOrigin = options.crossOrigin === true ? 'anonymous' : options.crossOrigin;\n    /**\n     * A timeout in milliseconds for the load. If the load takes longer than this time\n     * it is cancelled and the load is considered a failure. If this value is set to `0`\n     * then there is no explicit timeout.\n     *\n     * @member {number}\n     */\n\n    this.timeout = options.timeout || 0;\n    /**\n     * The method of loading to use for this resource.\n     *\n     * @member {Resource.LOAD_TYPE}\n     */\n\n    this.loadType = options.loadType || this._determineLoadType();\n    /**\n     * The type used to load the resource via XHR. If unset, determined automatically.\n     *\n     * @member {string}\n     */\n\n    this.xhrType = options.xhrType;\n    /**\n     * Extra info for middleware, and controlling specifics about how the resource loads.\n     *\n     * Note that if you pass in a `loadElement`, the Resource class takes ownership of it.\n     * Meaning it will modify it as it sees fit.\n     *\n     * @member {Resource.IMetadata}\n     */\n\n    this.metadata = options.metadata || {};\n    /**\n     * The error that occurred while loading (if any).\n     *\n     * @readonly\n     * @member {Error}\n     */\n\n    this.error = null;\n    /**\n     * The XHR object that was used to load this resource. This is only set\n     * when `loadType` is `Resource.LOAD_TYPE.XHR`.\n     *\n     * @readonly\n     * @member {XMLHttpRequest}\n     */\n\n    this.xhr = null;\n    /**\n     * The child resources this resource owns.\n     *\n     * @readonly\n     * @member {Resource[]}\n     */\n\n    this.children = [];\n    /**\n     * The resource type.\n     *\n     * @readonly\n     * @member {Resource.TYPE}\n     */\n\n    this.type = Resource.TYPE.UNKNOWN;\n    /**\n     * The progress chunk owned by this resource.\n     *\n     * @readonly\n     * @member {number}\n     */\n\n    this.progressChunk = 0;\n    /**\n     * The `dequeue` method that will be used a storage place for the async queue dequeue method\n     * used privately by the loader.\n     *\n     * @private\n     * @member {function}\n     */\n\n    this._dequeue = _noop$1;\n    /**\n     * Used a storage place for the on load binding used privately by the loader.\n     *\n     * @private\n     * @member {function}\n     */\n\n    this._onLoadBinding = null;\n    /**\n     * The timer for element loads to check if they timeout.\n     *\n     * @private\n     * @member {number}\n     */\n\n    this._elementTimer = 0;\n    /**\n     * The `complete` function bound to this resource's context.\n     *\n     * @private\n     * @member {function}\n     */\n\n    this._boundComplete = this.complete.bind(this);\n    /**\n     * The `_onError` function bound to this resource's context.\n     *\n     * @private\n     * @member {function}\n     */\n\n    this._boundOnError = this._onError.bind(this);\n    /**\n     * The `_onProgress` function bound to this resource's context.\n     *\n     * @private\n     * @member {function}\n     */\n\n    this._boundOnProgress = this._onProgress.bind(this);\n    /**\n     * The `_onTimeout` function bound to this resource's context.\n     *\n     * @private\n     * @member {function}\n     */\n\n    this._boundOnTimeout = this._onTimeout.bind(this); // xhr callbacks\n\n    this._boundXhrOnError = this._xhrOnError.bind(this);\n    this._boundXhrOnTimeout = this._xhrOnTimeout.bind(this);\n    this._boundXhrOnAbort = this._xhrOnAbort.bind(this);\n    this._boundXhrOnLoad = this._xhrOnLoad.bind(this);\n    /**\n     * Dispatched when the resource beings to load.\n     *\n     * The callback looks like {@link Resource.OnStartSignal}.\n     *\n     * @member {Signal<Resource.OnStartSignal>}\n     */\n\n    this.onStart = new Signal();\n    /**\n     * Dispatched each time progress of this resource load updates.\n     * Not all resources types and loader systems can support this event\n     * so sometimes it may not be available. If the resource\n     * is being loaded on a modern browser, using XHR, and the remote server\n     * properly sets Content-Length headers, then this will be available.\n     *\n     * The callback looks like {@link Resource.OnProgressSignal}.\n     *\n     * @member {Signal<Resource.OnProgressSignal>}\n     */\n\n    this.onProgress = new Signal();\n    /**\n     * Dispatched once this resource has loaded, if there was an error it will\n     * be in the `error` property.\n     *\n     * The callback looks like {@link Resource.OnCompleteSignal}.\n     *\n     * @member {Signal<Resource.OnCompleteSignal>}\n     */\n\n    this.onComplete = new Signal();\n    /**\n     * Dispatched after this resource has had all the *after* middleware run on it.\n     *\n     * The callback looks like {@link Resource.OnCompleteSignal}.\n     *\n     * @member {Signal<Resource.OnCompleteSignal>}\n     */\n\n    this.onAfterMiddleware = new Signal();\n  }\n  /**\n   * When the resource starts to load.\n   *\n   * @memberof Resource\n   * @callback OnStartSignal\n   * @param {Resource} resource - The resource that the event happened on.\n   */\n\n  /**\n   * When the resource reports loading progress.\n   *\n   * @memberof Resource\n   * @callback OnProgressSignal\n   * @param {Resource} resource - The resource that the event happened on.\n   * @param {number} percentage - The progress of the load in the range [0, 1].\n   */\n\n  /**\n   * When the resource finishes loading.\n   *\n   * @memberof Resource\n   * @callback OnCompleteSignal\n   * @param {Resource} resource - The resource that the event happened on.\n   */\n\n  /**\n   * @memberof Resource\n   * @typedef {object} IMetadata\n   * @property {HTMLImageElement|HTMLAudioElement|HTMLVideoElement} [loadElement=null] - The\n   *      element to use for loading, instead of creating one.\n   * @property {boolean} [skipSource=false] - Skips adding source(s) to the load element. This\n   *      is useful if you want to pass in a `loadElement` that you already added load sources to.\n   * @property {string|string[]} [mimeType] - The mime type to use for the source element\n   *      of a video/audio elment. If the urls are an array, you can pass this as an array as well\n   *      where each index is the mime type to use for the corresponding url index.\n   */\n\n  /**\n   * Stores whether or not this url is a data url.\n   *\n   * @readonly\n   * @member {boolean}\n   */\n\n\n  var _proto = Resource.prototype;\n  /**\n   * Marks the resource as complete.\n   *\n   */\n\n  _proto.complete = function complete() {\n    this._clearEvents();\n\n    this._finish();\n  }\n  /**\n   * Aborts the loading of this resource, with an optional message.\n   *\n   * @param {string} message - The message to use for the error\n   */\n  ;\n\n  _proto.abort = function abort(message) {\n    // abort can be called multiple times, ignore subsequent calls.\n    if (this.error) {\n      return;\n    } // store error\n\n\n    this.error = new Error(message); // clear events before calling aborts\n\n    this._clearEvents(); // abort the actual loading\n\n\n    if (this.xhr) {\n      this.xhr.abort();\n    } else if (this.xdr) {\n      this.xdr.abort();\n    } else if (this.data) {\n      // single source\n      if (this.data.src) {\n        this.data.src = Resource.EMPTY_GIF;\n      } // multi-source\n      else {\n          while (this.data.firstChild) {\n            this.data.removeChild(this.data.firstChild);\n          }\n        }\n    } // done now.\n\n\n    this._finish();\n  }\n  /**\n   * Kicks off loading of this resource. This method is asynchronous.\n   *\n   * @param {Resource.OnCompleteSignal} [cb] - Optional callback to call once the resource is loaded.\n   */\n  ;\n\n  _proto.load = function load(cb) {\n    var _this = this;\n\n    if (this.isLoading) {\n      return;\n    }\n\n    if (this.isComplete) {\n      if (cb) {\n        setTimeout(function () {\n          return cb(_this);\n        }, 1);\n      }\n\n      return;\n    } else if (cb) {\n      this.onComplete.once(cb);\n    }\n\n    this._setFlag(Resource.STATUS_FLAGS.LOADING, true);\n\n    this.onStart.dispatch(this); // if unset, determine the value\n\n    if (this.crossOrigin === false || typeof this.crossOrigin !== 'string') {\n      this.crossOrigin = this._determineCrossOrigin(this.url);\n    }\n\n    switch (this.loadType) {\n      case Resource.LOAD_TYPE.IMAGE:\n        this.type = Resource.TYPE.IMAGE;\n\n        this._loadElement('image');\n\n        break;\n\n      case Resource.LOAD_TYPE.AUDIO:\n        this.type = Resource.TYPE.AUDIO;\n\n        this._loadSourceElement('audio');\n\n        break;\n\n      case Resource.LOAD_TYPE.VIDEO:\n        this.type = Resource.TYPE.VIDEO;\n\n        this._loadSourceElement('video');\n\n        break;\n\n      case Resource.LOAD_TYPE.XHR:\n      /* falls through */\n\n      default:\n        if (useXdr && this.crossOrigin) {\n          this._loadXdr();\n        } else {\n          this._loadXhr();\n        }\n\n        break;\n    }\n  }\n  /**\n   * Checks if the flag is set.\n   *\n   * @private\n   * @param {number} flag - The flag to check.\n   * @return {boolean} True if the flag is set.\n   */\n  ;\n\n  _proto._hasFlag = function _hasFlag(flag) {\n    return (this._flags & flag) !== 0;\n  }\n  /**\n   * (Un)Sets the flag.\n   *\n   * @private\n   * @param {number} flag - The flag to (un)set.\n   * @param {boolean} value - Whether to set or (un)set the flag.\n   */\n  ;\n\n  _proto._setFlag = function _setFlag(flag, value) {\n    this._flags = value ? this._flags | flag : this._flags & ~flag;\n  }\n  /**\n   * Clears all the events from the underlying loading source.\n   *\n   * @private\n   */\n  ;\n\n  _proto._clearEvents = function _clearEvents() {\n    clearTimeout(this._elementTimer);\n\n    if (this.data && this.data.removeEventListener) {\n      this.data.removeEventListener('error', this._boundOnError, false);\n      this.data.removeEventListener('load', this._boundComplete, false);\n      this.data.removeEventListener('progress', this._boundOnProgress, false);\n      this.data.removeEventListener('canplaythrough', this._boundComplete, false);\n    }\n\n    if (this.xhr) {\n      if (this.xhr.removeEventListener) {\n        this.xhr.removeEventListener('error', this._boundXhrOnError, false);\n        this.xhr.removeEventListener('timeout', this._boundXhrOnTimeout, false);\n        this.xhr.removeEventListener('abort', this._boundXhrOnAbort, false);\n        this.xhr.removeEventListener('progress', this._boundOnProgress, false);\n        this.xhr.removeEventListener('load', this._boundXhrOnLoad, false);\n      } else {\n        this.xhr.onerror = null;\n        this.xhr.ontimeout = null;\n        this.xhr.onprogress = null;\n        this.xhr.onload = null;\n      }\n    }\n  }\n  /**\n   * Finalizes the load.\n   *\n   * @private\n   */\n  ;\n\n  _proto._finish = function _finish() {\n    if (this.isComplete) {\n      throw new Error('Complete called again for an already completed resource.');\n    }\n\n    this._setFlag(Resource.STATUS_FLAGS.COMPLETE, true);\n\n    this._setFlag(Resource.STATUS_FLAGS.LOADING, false);\n\n    this.onComplete.dispatch(this);\n  }\n  /**\n   * Loads this resources using an element that has a single source,\n   * like an HTMLImageElement.\n   *\n   * @private\n   * @param {string} type - The type of element to use.\n   */\n  ;\n\n  _proto._loadElement = function _loadElement(type) {\n    if (this.metadata.loadElement) {\n      this.data = this.metadata.loadElement;\n    } else if (type === 'image' && typeof window.Image !== 'undefined') {\n      this.data = new Image();\n    } else {\n      this.data = document.createElement(type);\n    }\n\n    if (this.crossOrigin) {\n      this.data.crossOrigin = this.crossOrigin;\n    }\n\n    if (!this.metadata.skipSource) {\n      this.data.src = this.url;\n    }\n\n    this.data.addEventListener('error', this._boundOnError, false);\n    this.data.addEventListener('load', this._boundComplete, false);\n    this.data.addEventListener('progress', this._boundOnProgress, false);\n\n    if (this.timeout) {\n      this._elementTimer = setTimeout(this._boundOnTimeout, this.timeout);\n    }\n  }\n  /**\n   * Loads this resources using an element that has multiple sources,\n   * like an HTMLAudioElement or HTMLVideoElement.\n   *\n   * @private\n   * @param {string} type - The type of element to use.\n   */\n  ;\n\n  _proto._loadSourceElement = function _loadSourceElement(type) {\n    if (this.metadata.loadElement) {\n      this.data = this.metadata.loadElement;\n    } else if (type === 'audio' && typeof window.Audio !== 'undefined') {\n      this.data = new Audio();\n    } else {\n      this.data = document.createElement(type);\n    }\n\n    if (this.data === null) {\n      this.abort(\"Unsupported element: \" + type);\n      return;\n    }\n\n    if (this.crossOrigin) {\n      this.data.crossOrigin = this.crossOrigin;\n    }\n\n    if (!this.metadata.skipSource) {\n      // support for CocoonJS Canvas+ runtime, lacks document.createElement('source')\n      if (navigator.isCocoonJS) {\n        this.data.src = Array.isArray(this.url) ? this.url[0] : this.url;\n      } else if (Array.isArray(this.url)) {\n        var mimeTypes = this.metadata.mimeType;\n\n        for (var i = 0; i < this.url.length; ++i) {\n          this.data.appendChild(this._createSource(type, this.url[i], Array.isArray(mimeTypes) ? mimeTypes[i] : mimeTypes));\n        }\n      } else {\n        var _mimeTypes = this.metadata.mimeType;\n        this.data.appendChild(this._createSource(type, this.url, Array.isArray(_mimeTypes) ? _mimeTypes[0] : _mimeTypes));\n      }\n    }\n\n    this.data.addEventListener('error', this._boundOnError, false);\n    this.data.addEventListener('load', this._boundComplete, false);\n    this.data.addEventListener('progress', this._boundOnProgress, false);\n    this.data.addEventListener('canplaythrough', this._boundComplete, false);\n    this.data.load();\n\n    if (this.timeout) {\n      this._elementTimer = setTimeout(this._boundOnTimeout, this.timeout);\n    }\n  }\n  /**\n   * Loads this resources using an XMLHttpRequest.\n   *\n   * @private\n   */\n  ;\n\n  _proto._loadXhr = function _loadXhr() {\n    // if unset, determine the value\n    if (typeof this.xhrType !== 'string') {\n      this.xhrType = this._determineXhrType();\n    }\n\n    var xhr = this.xhr = new XMLHttpRequest(); // set the request type and url\n\n    xhr.open('GET', this.url, true);\n    xhr.timeout = this.timeout; // load json as text and parse it ourselves. We do this because some browsers\n    // *cough* safari *cough* can't deal with it.\n\n    if (this.xhrType === Resource.XHR_RESPONSE_TYPE.JSON || this.xhrType === Resource.XHR_RESPONSE_TYPE.DOCUMENT) {\n      xhr.responseType = Resource.XHR_RESPONSE_TYPE.TEXT;\n    } else {\n      xhr.responseType = this.xhrType;\n    }\n\n    xhr.addEventListener('error', this._boundXhrOnError, false);\n    xhr.addEventListener('timeout', this._boundXhrOnTimeout, false);\n    xhr.addEventListener('abort', this._boundXhrOnAbort, false);\n    xhr.addEventListener('progress', this._boundOnProgress, false);\n    xhr.addEventListener('load', this._boundXhrOnLoad, false);\n    xhr.send();\n  }\n  /**\n   * Loads this resources using an XDomainRequest. This is here because we need to support IE9 (gross).\n   *\n   * @private\n   */\n  ;\n\n  _proto._loadXdr = function _loadXdr() {\n    // if unset, determine the value\n    if (typeof this.xhrType !== 'string') {\n      this.xhrType = this._determineXhrType();\n    }\n\n    var xdr = this.xhr = new XDomainRequest(); // eslint-disable-line no-undef\n    // XDomainRequest has a few quirks. Occasionally it will abort requests\n    // A way to avoid this is to make sure ALL callbacks are set even if not used\n    // More info here: http://stackoverflow.com/questions/15786966/xdomainrequest-aborts-post-on-ie-9\n\n    xdr.timeout = this.timeout || 5000; // XDR needs a timeout value or it breaks in IE9\n\n    xdr.onerror = this._boundXhrOnError;\n    xdr.ontimeout = this._boundXhrOnTimeout;\n    xdr.onprogress = this._boundOnProgress;\n    xdr.onload = this._boundXhrOnLoad;\n    xdr.open('GET', this.url, true); // Note: The xdr.send() call is wrapped in a timeout to prevent an\n    // issue with the interface where some requests are lost if multiple\n    // XDomainRequests are being sent at the same time.\n    // Some info here: https://github.com/photonstorm/phaser/issues/1248\n\n    setTimeout(function () {\n      return xdr.send();\n    }, 1);\n  }\n  /**\n   * Creates a source used in loading via an element.\n   *\n   * @private\n   * @param {string} type - The element type (video or audio).\n   * @param {string} url - The source URL to load from.\n   * @param {string} [mime] - The mime type of the video\n   * @return {HTMLSourceElement} The source element.\n   */\n  ;\n\n  _proto._createSource = function _createSource(type, url, mime) {\n    if (!mime) {\n      mime = type + \"/\" + this._getExtension(url);\n    }\n\n    var source = document.createElement('source');\n    source.src = url;\n    source.type = mime;\n    return source;\n  }\n  /**\n   * Called if a load errors out.\n   *\n   * @param {Event} event - The error event from the element that emits it.\n   * @private\n   */\n  ;\n\n  _proto._onError = function _onError(event) {\n    this.abort(\"Failed to load element using: \" + event.target.nodeName);\n  }\n  /**\n   * Called if a load progress event fires for an element or xhr/xdr.\n   *\n   * @private\n   * @param {XMLHttpRequestProgressEvent|Event} event - Progress event.\n   */\n  ;\n\n  _proto._onProgress = function _onProgress(event) {\n    if (event && event.lengthComputable) {\n      this.onProgress.dispatch(this, event.loaded / event.total);\n    }\n  }\n  /**\n   * Called if a timeout event fires for an element.\n   *\n   * @private\n   */\n  ;\n\n  _proto._onTimeout = function _onTimeout() {\n    this.abort(\"Load timed out.\");\n  }\n  /**\n   * Called if an error event fires for xhr/xdr.\n   *\n   * @private\n   */\n  ;\n\n  _proto._xhrOnError = function _xhrOnError() {\n    var xhr = this.xhr;\n    this.abort(reqType(xhr) + \" Request failed. Status: \" + xhr.status + \", text: \\\"\" + xhr.statusText + \"\\\"\");\n  }\n  /**\n   * Called if an error event fires for xhr/xdr.\n   *\n   * @private\n   */\n  ;\n\n  _proto._xhrOnTimeout = function _xhrOnTimeout() {\n    var xhr = this.xhr;\n    this.abort(reqType(xhr) + \" Request timed out.\");\n  }\n  /**\n   * Called if an abort event fires for xhr/xdr.\n   *\n   * @private\n   */\n  ;\n\n  _proto._xhrOnAbort = function _xhrOnAbort() {\n    var xhr = this.xhr;\n    this.abort(reqType(xhr) + \" Request was aborted by the user.\");\n  }\n  /**\n   * Called when data successfully loads from an xhr/xdr request.\n   *\n   * @private\n   * @param {XMLHttpRequestLoadEvent|Event} event - Load event\n   */\n  ;\n\n  _proto._xhrOnLoad = function _xhrOnLoad() {\n    var xhr = this.xhr;\n    var text = '';\n    var status = typeof xhr.status === 'undefined' ? STATUS_OK : xhr.status; // XDR has no `.status`, assume 200.\n    // responseText is accessible only if responseType is '' or 'text' and on older browsers\n\n    if (xhr.responseType === '' || xhr.responseType === 'text' || typeof xhr.responseType === 'undefined') {\n      text = xhr.responseText;\n    } // status can be 0 when using the `file://` protocol so we also check if a response is set.\n    // If it has a response, we assume 200; otherwise a 0 status code with no contents is an aborted request.\n\n\n    if (status === STATUS_NONE && (text.length > 0 || xhr.responseType === Resource.XHR_RESPONSE_TYPE.BUFFER)) {\n      status = STATUS_OK;\n    } // handle IE9 bug: http://stackoverflow.com/questions/10046972/msie-returns-status-code-of-1223-for-ajax-request\n    else if (status === STATUS_IE_BUG_EMPTY) {\n        status = STATUS_EMPTY;\n      }\n\n    var statusType = status / 100 | 0;\n\n    if (statusType === STATUS_TYPE_OK) {\n      // if text, just return it\n      if (this.xhrType === Resource.XHR_RESPONSE_TYPE.TEXT) {\n        this.data = text;\n        this.type = Resource.TYPE.TEXT;\n      } // if json, parse into json object\n      else if (this.xhrType === Resource.XHR_RESPONSE_TYPE.JSON) {\n          try {\n            this.data = JSON.parse(text);\n            this.type = Resource.TYPE.JSON;\n          } catch (e) {\n            this.abort(\"Error trying to parse loaded json: \" + e);\n            return;\n          }\n        } // if xml, parse into an xml document or div element\n        else if (this.xhrType === Resource.XHR_RESPONSE_TYPE.DOCUMENT) {\n            try {\n              if (window.DOMParser) {\n                var domparser = new DOMParser();\n                this.data = domparser.parseFromString(text, 'text/xml');\n              } else {\n                var div = document.createElement('div');\n                div.innerHTML = text;\n                this.data = div;\n              }\n\n              this.type = Resource.TYPE.XML;\n            } catch (e) {\n              this.abort(\"Error trying to parse loaded xml: \" + e);\n              return;\n            }\n          } // other types just return the response\n          else {\n              this.data = xhr.response || text;\n            }\n    } else {\n      this.abort(\"[\" + xhr.status + \"] \" + xhr.statusText + \": \" + xhr.responseURL);\n      return;\n    }\n\n    this.complete();\n  }\n  /**\n   * Sets the `crossOrigin` property for this resource based on if the url\n   * for this resource is cross-origin. If crossOrigin was manually set, this\n   * function does nothing.\n   *\n   * @private\n   * @param {string} url - The url to test.\n   * @param {object} [loc=window.location] - The location object to test against.\n   * @return {string} The crossOrigin value to use (or empty string for none).\n   */\n  ;\n\n  _proto._determineCrossOrigin = function _determineCrossOrigin(url, loc) {\n    // data: and javascript: urls are considered same-origin\n    if (url.indexOf('data:') === 0) {\n      return '';\n    } // A sandboxed iframe without the 'allow-same-origin' attribute will have a special\n    // origin designed not to match window.location.origin, and will always require\n    // crossOrigin requests regardless of whether the location matches.\n\n\n    if (window.origin !== window.location.origin) {\n      return 'anonymous';\n    } // default is window.location\n\n\n    loc = loc || window.location;\n\n    if (!tempAnchor) {\n      tempAnchor = document.createElement('a');\n    } // let the browser determine the full href for the url of this resource and then\n    // parse with the node url lib, we can't use the properties of the anchor element\n    // because they don't work in IE9 :(\n\n\n    tempAnchor.href = url;\n    url = parseUri(tempAnchor.href, {\n      strictMode: true\n    });\n    var samePort = !url.port && loc.port === '' || url.port === loc.port;\n    var protocol = url.protocol ? url.protocol + \":\" : ''; // if cross origin\n\n    if (url.host !== loc.hostname || !samePort || protocol !== loc.protocol) {\n      return 'anonymous';\n    }\n\n    return '';\n  }\n  /**\n   * Determines the responseType of an XHR request based on the extension of the\n   * resource being loaded.\n   *\n   * @private\n   * @return {Resource.XHR_RESPONSE_TYPE} The responseType to use.\n   */\n  ;\n\n  _proto._determineXhrType = function _determineXhrType() {\n    return Resource._xhrTypeMap[this.extension] || Resource.XHR_RESPONSE_TYPE.TEXT;\n  }\n  /**\n   * Determines the loadType of a resource based on the extension of the\n   * resource being loaded.\n   *\n   * @private\n   * @return {Resource.LOAD_TYPE} The loadType to use.\n   */\n  ;\n\n  _proto._determineLoadType = function _determineLoadType() {\n    return Resource._loadTypeMap[this.extension] || Resource.LOAD_TYPE.XHR;\n  }\n  /**\n   * Extracts the extension (sans '.') of the file being loaded by the resource.\n   *\n   * @private\n   * @return {string} The extension.\n   */\n  ;\n\n  _proto._getExtension = function _getExtension() {\n    var url = this.url;\n    var ext = '';\n\n    if (this.isDataUrl) {\n      var slashIndex = url.indexOf('/');\n      ext = url.substring(slashIndex + 1, url.indexOf(';', slashIndex));\n    } else {\n      var queryStart = url.indexOf('?');\n      var hashStart = url.indexOf('#');\n      var index = Math.min(queryStart > -1 ? queryStart : url.length, hashStart > -1 ? hashStart : url.length);\n      url = url.substring(0, index);\n      ext = url.substring(url.lastIndexOf('.') + 1);\n    }\n\n    return ext.toLowerCase();\n  }\n  /**\n   * Determines the mime type of an XHR request based on the responseType of\n   * resource being loaded.\n   *\n   * @private\n   * @param {Resource.XHR_RESPONSE_TYPE} type - The type to get a mime type for.\n   * @return {string} The mime type to use.\n   */\n  ;\n\n  _proto._getMimeFromXhrType = function _getMimeFromXhrType(type) {\n    switch (type) {\n      case Resource.XHR_RESPONSE_TYPE.BUFFER:\n        return 'application/octet-binary';\n\n      case Resource.XHR_RESPONSE_TYPE.BLOB:\n        return 'application/blob';\n\n      case Resource.XHR_RESPONSE_TYPE.DOCUMENT:\n        return 'application/xml';\n\n      case Resource.XHR_RESPONSE_TYPE.JSON:\n        return 'application/json';\n\n      case Resource.XHR_RESPONSE_TYPE.DEFAULT:\n      case Resource.XHR_RESPONSE_TYPE.TEXT:\n      /* falls through */\n\n      default:\n        return 'text/plain';\n    }\n  };\n\n  _createClass(Resource, [{\n    key: \"isDataUrl\",\n    get: function get() {\n      return this._hasFlag(Resource.STATUS_FLAGS.DATA_URL);\n    }\n    /**\n     * Describes if this resource has finished loading. Is true when the resource has completely\n     * loaded.\n     *\n     * @readonly\n     * @member {boolean}\n     */\n\n  }, {\n    key: \"isComplete\",\n    get: function get() {\n      return this._hasFlag(Resource.STATUS_FLAGS.COMPLETE);\n    }\n    /**\n     * Describes if this resource is currently loading. Is true when the resource starts loading,\n     * and is false again when complete.\n     *\n     * @readonly\n     * @member {boolean}\n     */\n\n  }, {\n    key: \"isLoading\",\n    get: function get() {\n      return this._hasFlag(Resource.STATUS_FLAGS.LOADING);\n    }\n  }]);\n\n  return Resource;\n}();\n/**\n * The types of resources a resource could represent.\n *\n * @static\n * @readonly\n * @enum {number}\n */\n\n\nResource.STATUS_FLAGS = {\n  NONE: 0,\n  DATA_URL: 1 << 0,\n  COMPLETE: 1 << 1,\n  LOADING: 1 << 2\n};\n/**\n * The types of resources a resource could represent.\n *\n * @static\n * @readonly\n * @enum {number}\n */\n\nResource.TYPE = {\n  UNKNOWN: 0,\n  JSON: 1,\n  XML: 2,\n  IMAGE: 3,\n  AUDIO: 4,\n  VIDEO: 5,\n  TEXT: 6\n};\n/**\n * The types of loading a resource can use.\n *\n * @static\n * @readonly\n * @enum {number}\n */\n\nResource.LOAD_TYPE = {\n  /** Uses XMLHttpRequest to load the resource. */\n  XHR: 1,\n\n  /** Uses an `Image` object to load the resource. */\n  IMAGE: 2,\n\n  /** Uses an `Audio` object to load the resource. */\n  AUDIO: 3,\n\n  /** Uses a `Video` object to load the resource. */\n  VIDEO: 4\n};\n/**\n * The XHR ready states, used internally.\n *\n * @static\n * @readonly\n * @enum {string}\n */\n\nResource.XHR_RESPONSE_TYPE = {\n  /** string */\n  DEFAULT: 'text',\n\n  /** ArrayBuffer */\n  BUFFER: 'arraybuffer',\n\n  /** Blob */\n  BLOB: 'blob',\n\n  /** Document */\n  DOCUMENT: 'document',\n\n  /** Object */\n  JSON: 'json',\n\n  /** String */\n  TEXT: 'text'\n};\nResource._loadTypeMap = {\n  // images\n  gif: Resource.LOAD_TYPE.IMAGE,\n  png: Resource.LOAD_TYPE.IMAGE,\n  bmp: Resource.LOAD_TYPE.IMAGE,\n  jpg: Resource.LOAD_TYPE.IMAGE,\n  jpeg: Resource.LOAD_TYPE.IMAGE,\n  tif: Resource.LOAD_TYPE.IMAGE,\n  tiff: Resource.LOAD_TYPE.IMAGE,\n  webp: Resource.LOAD_TYPE.IMAGE,\n  tga: Resource.LOAD_TYPE.IMAGE,\n  svg: Resource.LOAD_TYPE.IMAGE,\n  'svg+xml': Resource.LOAD_TYPE.IMAGE,\n  // for SVG data urls\n  // audio\n  mp3: Resource.LOAD_TYPE.AUDIO,\n  ogg: Resource.LOAD_TYPE.AUDIO,\n  wav: Resource.LOAD_TYPE.AUDIO,\n  // videos\n  mp4: Resource.LOAD_TYPE.VIDEO,\n  webm: Resource.LOAD_TYPE.VIDEO\n};\nResource._xhrTypeMap = {\n  // xml\n  xhtml: Resource.XHR_RESPONSE_TYPE.DOCUMENT,\n  html: Resource.XHR_RESPONSE_TYPE.DOCUMENT,\n  htm: Resource.XHR_RESPONSE_TYPE.DOCUMENT,\n  xml: Resource.XHR_RESPONSE_TYPE.DOCUMENT,\n  tmx: Resource.XHR_RESPONSE_TYPE.DOCUMENT,\n  svg: Resource.XHR_RESPONSE_TYPE.DOCUMENT,\n  // This was added to handle Tiled Tileset XML, but .tsx is also a TypeScript React Component.\n  // Since it is way less likely for people to be loading TypeScript files instead of Tiled files,\n  // this should probably be fine.\n  tsx: Resource.XHR_RESPONSE_TYPE.DOCUMENT,\n  // images\n  gif: Resource.XHR_RESPONSE_TYPE.BLOB,\n  png: Resource.XHR_RESPONSE_TYPE.BLOB,\n  bmp: Resource.XHR_RESPONSE_TYPE.BLOB,\n  jpg: Resource.XHR_RESPONSE_TYPE.BLOB,\n  jpeg: Resource.XHR_RESPONSE_TYPE.BLOB,\n  tif: Resource.XHR_RESPONSE_TYPE.BLOB,\n  tiff: Resource.XHR_RESPONSE_TYPE.BLOB,\n  webp: Resource.XHR_RESPONSE_TYPE.BLOB,\n  tga: Resource.XHR_RESPONSE_TYPE.BLOB,\n  // json\n  json: Resource.XHR_RESPONSE_TYPE.JSON,\n  // text\n  text: Resource.XHR_RESPONSE_TYPE.TEXT,\n  txt: Resource.XHR_RESPONSE_TYPE.TEXT,\n  // fonts\n  ttf: Resource.XHR_RESPONSE_TYPE.BUFFER,\n  otf: Resource.XHR_RESPONSE_TYPE.BUFFER\n}; // We can't set the `src` attribute to empty string, so on abort we set it to this 1px transparent gif\n\nResource.EMPTY_GIF = 'data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw==';\n/**\n * Quick helper to set a value on one of the extension maps. Ensures there is no\n * dot at the start of the extension.\n *\n * @ignore\n * @param {object} map - The map to set on.\n * @param {string} extname - The extension (or key) to set.\n * @param {number} val - The value to set.\n */\n\nfunction setExtMap(map, extname, val) {\n  if (extname && extname.indexOf('.') === 0) {\n    extname = extname.substring(1);\n  }\n\n  if (!extname) {\n    return;\n  }\n\n  map[extname] = val;\n}\n/**\n * Quick helper to get string xhr type.\n *\n * @ignore\n * @param {XMLHttpRequest|XDomainRequest} xhr - The request to check.\n * @return {string} The type.\n */\n\n\nfunction reqType(xhr) {\n  return xhr.toString().replace('object ', '');\n}\n\nvar _keyStr = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';\n/**\n * Encodes binary into base64.\n *\n * @function encodeBinary\n * @param {string} input The input data to encode.\n * @returns {string} The encoded base64 string\n */\n\nfunction encodeBinary(input) {\n  var output = '';\n  var inx = 0;\n\n  while (inx < input.length) {\n    // Fill byte buffer array\n    var bytebuffer = [0, 0, 0];\n    var encodedCharIndexes = [0, 0, 0, 0];\n\n    for (var jnx = 0; jnx < bytebuffer.length; ++jnx) {\n      if (inx < input.length) {\n        // throw away high-order byte, as documented at:\n        // https://developer.mozilla.org/En/Using_XMLHttpRequest#Handling_binary_data\n        bytebuffer[jnx] = input.charCodeAt(inx++) & 0xff;\n      } else {\n        bytebuffer[jnx] = 0;\n      }\n    } // Get each encoded character, 6 bits at a time\n    // index 1: first 6 bits\n\n\n    encodedCharIndexes[0] = bytebuffer[0] >> 2; // index 2: second 6 bits (2 least significant bits from input byte 1 + 4 most significant bits from byte 2)\n\n    encodedCharIndexes[1] = (bytebuffer[0] & 0x3) << 4 | bytebuffer[1] >> 4; // index 3: third 6 bits (4 least significant bits from input byte 2 + 2 most significant bits from byte 3)\n\n    encodedCharIndexes[2] = (bytebuffer[1] & 0x0f) << 2 | bytebuffer[2] >> 6; // index 3: forth 6 bits (6 least significant bits from input byte 3)\n\n    encodedCharIndexes[3] = bytebuffer[2] & 0x3f; // Determine whether padding happened, and adjust accordingly\n\n    var paddingBytes = inx - (input.length - 1);\n\n    switch (paddingBytes) {\n      case 2:\n        // Set last 2 characters to padding char\n        encodedCharIndexes[3] = 64;\n        encodedCharIndexes[2] = 64;\n        break;\n\n      case 1:\n        // Set last character to padding char\n        encodedCharIndexes[3] = 64;\n        break;\n\n      default:\n        break;\n      // No padding - proceed\n    } // Now we will grab each appropriate character out of our keystring\n    // based on our index array and append it to the output string\n\n\n    for (var _jnx = 0; _jnx < encodedCharIndexes.length; ++_jnx) {\n      output += _keyStr.charAt(encodedCharIndexes[_jnx]);\n    }\n  }\n\n  return output;\n}\n\nvar Url = window.URL || window.webkitURL;\n/**\n * A middleware for transforming XHR loaded Blobs into more useful objects\n *\n * @memberof middleware\n * @function parsing\n * @example\n * import { Loader, middleware } from 'resource-loader';\n * const loader = new Loader();\n * loader.use(middleware.parsing);\n * @param {Resource} resource - Current Resource\n * @param {function} next - Callback when complete\n */\n\nfunction parsing(resource, next) {\n  if (!resource.data) {\n    next();\n    return;\n  } // if this was an XHR load of a blob\n\n\n  if (resource.xhr && resource.xhrType === Resource.XHR_RESPONSE_TYPE.BLOB) {\n    // if there is no blob support we probably got a binary string back\n    if (!window.Blob || typeof resource.data === 'string') {\n      var type = resource.xhr.getResponseHeader('content-type'); // this is an image, convert the binary string into a data url\n\n      if (type && type.indexOf('image') === 0) {\n        resource.data = new Image();\n        resource.data.src = \"data:\" + type + \";base64,\" + encodeBinary(resource.xhr.responseText);\n        resource.type = Resource.TYPE.IMAGE; // wait until the image loads and then callback\n\n        resource.data.onload = function () {\n          resource.data.onload = null;\n          next();\n        }; // next will be called on load\n\n\n        return;\n      }\n    } // if content type says this is an image, then we should transform the blob into an Image object\n    else if (resource.data.type.indexOf('image') === 0) {\n        var src = Url.createObjectURL(resource.data);\n        resource.blob = resource.data;\n        resource.data = new Image();\n        resource.data.src = src;\n        resource.type = Resource.TYPE.IMAGE; // cleanup the no longer used blob after the image loads\n        // TODO: Is this correct? Will the image be invalid after revoking?\n\n        resource.data.onload = function () {\n          Url.revokeObjectURL(src);\n          resource.data.onload = null;\n          next();\n        }; // next will be called on load.\n\n\n        return;\n      }\n  }\n\n  next();\n}\n/**\n * @namespace middleware\n */\n\n\nvar index = {\n  caching: caching,\n  parsing: parsing\n};\nvar MAX_PROGRESS = 100;\nvar rgxExtractUrlHash = /(#[\\w-]+)?$/;\n/**\n * Manages the state and loading of multiple resources to load.\n *\n * @class\n */\n\nvar Loader =\n/*#__PURE__*/\nfunction () {\n  /**\n   * @param {string} [baseUrl=''] - The base url for all resources loaded by this loader.\n   * @param {number} [concurrency=10] - The number of resources to load concurrently.\n   */\n  function Loader(baseUrl, concurrency) {\n    var _this = this;\n\n    if (baseUrl === void 0) {\n      baseUrl = '';\n    }\n\n    if (concurrency === void 0) {\n      concurrency = 10;\n    }\n    /**\n     * The base url for all resources loaded by this loader.\n     *\n     * @member {string}\n     */\n\n\n    this.baseUrl = baseUrl;\n    /**\n     * The progress percent of the loader going through the queue.\n     *\n     * @member {number}\n     * @default 0\n     */\n\n    this.progress = 0;\n    /**\n     * Loading state of the loader, true if it is currently loading resources.\n     *\n     * @member {boolean}\n     * @default false\n     */\n\n    this.loading = false;\n    /**\n     * A querystring to append to every URL added to the loader.\n     *\n     * This should be a valid query string *without* the question-mark (`?`). The loader will\n     * also *not* escape values for you. Make sure to escape your parameters with\n     * [`encodeURIComponent`](https://mdn.io/encodeURIComponent) before assigning this property.\n     *\n     * @example\n     * const loader = new Loader();\n     *\n     * loader.defaultQueryString = 'user=me&password=secret';\n     *\n     * // This will request 'image.png?user=me&password=secret'\n     * loader.add('image.png').load();\n     *\n     * loader.reset();\n     *\n     * // This will request 'image.png?v=1&user=me&password=secret'\n     * loader.add('iamge.png?v=1').load();\n     *\n     * @member {string}\n     * @default ''\n     */\n\n    this.defaultQueryString = '';\n    /**\n     * The middleware to run before loading each resource.\n     *\n     * @private\n     * @member {function[]}\n     */\n\n    this._beforeMiddleware = [];\n    /**\n     * The middleware to run after loading each resource.\n     *\n     * @private\n     * @member {function[]}\n     */\n\n    this._afterMiddleware = [];\n    /**\n     * The tracks the resources we are currently completing parsing for.\n     *\n     * @private\n     * @member {Resource[]}\n     */\n\n    this._resourcesParsing = [];\n    /**\n     * The `_loadResource` function bound with this object context.\n     *\n     * @private\n     * @member {function}\n     * @param {Resource} r - The resource to load\n     * @param {Function} d - The dequeue function\n     * @return {undefined}\n     */\n\n    this._boundLoadResource = function (r, d) {\n      return _this._loadResource(r, d);\n    };\n    /**\n     * The resources waiting to be loaded.\n     *\n     * @private\n     * @member {Resource[]}\n     */\n\n\n    this._queue = queue(this._boundLoadResource, concurrency);\n\n    this._queue.pause();\n    /**\n     * All the resources for this loader keyed by name.\n     *\n     * @member {object<string, Resource>}\n     */\n\n\n    this.resources = {};\n    /**\n     * Dispatched once per loaded or errored resource.\n     *\n     * The callback looks like {@link Loader.OnProgressSignal}.\n     *\n     * @member {Signal<Loader.OnProgressSignal>}\n     */\n\n    this.onProgress = new Signal();\n    /**\n     * Dispatched once per errored resource.\n     *\n     * The callback looks like {@link Loader.OnErrorSignal}.\n     *\n     * @member {Signal<Loader.OnErrorSignal>}\n     */\n\n    this.onError = new Signal();\n    /**\n     * Dispatched once per loaded resource.\n     *\n     * The callback looks like {@link Loader.OnLoadSignal}.\n     *\n     * @member {Signal<Loader.OnLoadSignal>}\n     */\n\n    this.onLoad = new Signal();\n    /**\n     * Dispatched when the loader begins to process the queue.\n     *\n     * The callback looks like {@link Loader.OnStartSignal}.\n     *\n     * @member {Signal<Loader.OnStartSignal>}\n     */\n\n    this.onStart = new Signal();\n    /**\n     * Dispatched when the queued resources all load.\n     *\n     * The callback looks like {@link Loader.OnCompleteSignal}.\n     *\n     * @member {Signal<Loader.OnCompleteSignal>}\n     */\n\n    this.onComplete = new Signal(); // Add default before middleware\n\n    for (var i = 0; i < Loader._defaultBeforeMiddleware.length; ++i) {\n      this.pre(Loader._defaultBeforeMiddleware[i]);\n    } // Add default after middleware\n\n\n    for (var _i = 0; _i < Loader._defaultAfterMiddleware.length; ++_i) {\n      this.use(Loader._defaultAfterMiddleware[_i]);\n    }\n  }\n  /**\n   * When the progress changes the loader and resource are disaptched.\n   *\n   * @memberof Loader\n   * @callback OnProgressSignal\n   * @param {Loader} loader - The loader the progress is advancing on.\n   * @param {Resource} resource - The resource that has completed or failed to cause the progress to advance.\n   */\n\n  /**\n   * When an error occurrs the loader and resource are disaptched.\n   *\n   * @memberof Loader\n   * @callback OnErrorSignal\n   * @param {Loader} loader - The loader the error happened in.\n   * @param {Resource} resource - The resource that caused the error.\n   */\n\n  /**\n   * When a load completes the loader and resource are disaptched.\n   *\n   * @memberof Loader\n   * @callback OnLoadSignal\n   * @param {Loader} loader - The loader that laoded the resource.\n   * @param {Resource} resource - The resource that has completed loading.\n   */\n\n  /**\n   * When the loader starts loading resources it dispatches this callback.\n   *\n   * @memberof Loader\n   * @callback OnStartSignal\n   * @param {Loader} loader - The loader that has started loading resources.\n   */\n\n  /**\n   * When the loader completes loading resources it dispatches this callback.\n   *\n   * @memberof Loader\n   * @callback OnCompleteSignal\n   * @param {Loader} loader - The loader that has finished loading resources.\n   */\n\n  /**\n   * Options for a call to `.add()`.\n   *\n   * @see Loader#add\n   *\n   * @typedef {object} IAddOptions\n   * @property {string} [name] - The name of the resource to load, if not passed the url is used.\n   * @property {string} [key] - Alias for `name`.\n   * @property {string} [url] - The url for this resource, relative to the baseUrl of this loader.\n   * @property {string|boolean} [crossOrigin] - Is this request cross-origin? Default is to\n   *      determine automatically.\n   * @property {number} [timeout=0] - A timeout in milliseconds for the load. If the load takes\n   *      longer than this time it is cancelled and the load is considered a failure. If this value is\n   *      set to `0` then there is no explicit timeout.\n   * @property {Resource.LOAD_TYPE} [loadType=Resource.LOAD_TYPE.XHR] - How should this resource\n   *      be loaded?\n   * @property {Resource.XHR_RESPONSE_TYPE} [xhrType=Resource.XHR_RESPONSE_TYPE.DEFAULT] - How\n   *      should the data being loaded be interpreted when using XHR?\n   * @property {Resource.OnCompleteSignal} [onComplete] - Callback to add an an onComplete signal istener.\n   * @property {Resource.OnCompleteSignal} [callback] - Alias for `onComplete`.\n   * @property {Resource.IMetadata} [metadata] - Extra configuration for middleware and the Resource object.\n   */\n\n  /* eslint-disable require-jsdoc,valid-jsdoc */\n\n  /**\n   * Adds a resource (or multiple resources) to the loader queue.\n   *\n   * This function can take a wide variety of different parameters. The only thing that is always\n   * required the url to load. All the following will work:\n   *\n   * ```js\n   * loader\n   *     // normal param syntax\n   *     .add('key', 'http://...', function () {})\n   *     .add('http://...', function () {})\n   *     .add('http://...')\n   *\n   *     // object syntax\n   *     .add({\n   *         name: 'key2',\n   *         url: 'http://...'\n   *     }, function () {})\n   *     .add({\n   *         url: 'http://...'\n   *     }, function () {})\n   *     .add({\n   *         name: 'key3',\n   *         url: 'http://...'\n   *         onComplete: function () {}\n   *     })\n   *     .add({\n   *         url: 'https://...',\n   *         onComplete: function () {},\n   *         crossOrigin: true\n   *     })\n   *\n   *     // you can also pass an array of objects or urls or both\n   *     .add([\n   *         { name: 'key4', url: 'http://...', onComplete: function () {} },\n   *         { url: 'http://...', onComplete: function () {} },\n   *         'http://...'\n   *     ])\n   *\n   *     // and you can use both params and options\n   *     .add('key', 'http://...', { crossOrigin: true }, function () {})\n   *     .add('http://...', { crossOrigin: true }, function () {});\n   * ```\n   *\n   * @function\n   * @variation 1\n   * @param {string} name - The name of the resource to load.\n   * @param {string} url - The url for this resource, relative to the baseUrl of this loader.\n   * @param {Resource.OnCompleteSignal} [callback] - Function to call when this specific resource completes loading.\n   * @return {this} Returns itself.\n   */\n\n  /**\n  * @function\n  * @variation 2\n  * @param {string} name - The name of the resource to load.\n  * @param {string} url - The url for this resource, relative to the baseUrl of this loader.\n  * @param {IAddOptions} [options] - The options for the load.\n  * @param {Resource.OnCompleteSignal} [callback] - Function to call when this specific resource completes loading.\n  * @return {this} Returns itself.\n  */\n\n  /**\n  * @function\n  * @variation 3\n  * @param {string} url - The url for this resource, relative to the baseUrl of this loader.\n  * @param {Resource.OnCompleteSignal} [callback] - Function to call when this specific resource completes loading.\n  * @return {this} Returns itself.\n  */\n\n  /**\n  * @function\n  * @variation 4\n  * @param {string} url - The url for this resource, relative to the baseUrl of this loader.\n  * @param {IAddOptions} [options] - The options for the load.\n  * @param {Resource.OnCompleteSignal} [callback] - Function to call when this specific resource completes loading.\n  * @return {this} Returns itself.\n  */\n\n  /**\n  * @function\n  * @variation 5\n  * @param {IAddOptions} options - The options for the load. This object must contain a `url` property.\n  * @param {Resource.OnCompleteSignal} [callback] - Function to call when this specific resource completes loading.\n  * @return {this} Returns itself.\n  */\n\n  /**\n  * @function\n  * @variation 6\n  * @param {Array<IAddOptions|string>} resources - An array of resources to load, where each is\n  *      either an object with the options or a string url. If you pass an object, it must contain a `url` property.\n  * @param {Resource.OnCompleteSignal} [callback] - Function to call when this specific resource completes loading.\n  * @return {this} Returns itself.\n  */\n\n\n  var _proto = Loader.prototype;\n\n  _proto.add = function add(name, url, options, cb) {\n    // special case of an array of objects or urls\n    if (Array.isArray(name)) {\n      for (var i = 0; i < name.length; ++i) {\n        this.add(name[i]);\n      }\n\n      return this;\n    } // if an object is passed instead of params\n\n\n    if (typeof name === 'object') {\n      cb = url || name.callback || name.onComplete;\n      options = name;\n      url = name.url;\n      name = name.name || name.key || name.url;\n    } // case where no name is passed shift all args over by one.\n\n\n    if (typeof url !== 'string') {\n      cb = options;\n      options = url;\n      url = name;\n    } // now that we shifted make sure we have a proper url.\n\n\n    if (typeof url !== 'string') {\n      throw new Error('No url passed to add resource to loader.');\n    } // options are optional so people might pass a function and no options\n\n\n    if (typeof options === 'function') {\n      cb = options;\n      options = null;\n    } // if loading already you can only add resources that have a parent.\n\n\n    if (this.loading && (!options || !options.parentResource)) {\n      throw new Error('Cannot add resources while the loader is running.');\n    } // check if resource already exists.\n\n\n    if (this.resources[name]) {\n      throw new Error(\"Resource named \\\"\" + name + \"\\\" already exists.\");\n    } // add base url if this isn't an absolute url\n\n\n    url = this._prepareUrl(url); // create the store the resource\n\n    this.resources[name] = new Resource(name, url, options);\n\n    if (typeof cb === 'function') {\n      this.resources[name].onAfterMiddleware.once(cb);\n    } // if actively loading, make sure to adjust progress chunks for that parent and its children\n\n\n    if (this.loading) {\n      var parent = options.parentResource;\n      var incompleteChildren = [];\n\n      for (var _i2 = 0; _i2 < parent.children.length; ++_i2) {\n        if (!parent.children[_i2].isComplete) {\n          incompleteChildren.push(parent.children[_i2]);\n        }\n      }\n\n      var fullChunk = parent.progressChunk * (incompleteChildren.length + 1); // +1 for parent\n\n      var eachChunk = fullChunk / (incompleteChildren.length + 2); // +2 for parent & new child\n\n      parent.children.push(this.resources[name]);\n      parent.progressChunk = eachChunk;\n\n      for (var _i3 = 0; _i3 < incompleteChildren.length; ++_i3) {\n        incompleteChildren[_i3].progressChunk = eachChunk;\n      }\n\n      this.resources[name].progressChunk = eachChunk;\n    } // add the resource to the queue\n\n\n    this._queue.push(this.resources[name]);\n\n    return this;\n  }\n  /* eslint-enable require-jsdoc,valid-jsdoc */\n\n  /**\n   * Sets up a middleware function that will run *before* the\n   * resource is loaded.\n   *\n   * @param {function} fn - The middleware function to register.\n   * @return {this} Returns itself.\n   */\n  ;\n\n  _proto.pre = function pre(fn) {\n    this._beforeMiddleware.push(fn);\n\n    return this;\n  }\n  /**\n   * Sets up a middleware function that will run *after* the\n   * resource is loaded.\n   *\n   * @param {function} fn - The middleware function to register.\n   * @return {this} Returns itself.\n   */\n  ;\n\n  _proto.use = function use(fn) {\n    this._afterMiddleware.push(fn);\n\n    return this;\n  }\n  /**\n   * Resets the queue of the loader to prepare for a new load.\n   *\n   * @return {this} Returns itself.\n   */\n  ;\n\n  _proto.reset = function reset() {\n    this.progress = 0;\n    this.loading = false;\n\n    this._queue.kill();\n\n    this._queue.pause(); // abort all resource loads\n\n\n    for (var k in this.resources) {\n      var res = this.resources[k];\n\n      if (res._onLoadBinding) {\n        res._onLoadBinding.detach();\n      }\n\n      if (res.isLoading) {\n        res.abort();\n      }\n    }\n\n    this.resources = {};\n    return this;\n  }\n  /**\n   * Starts loading the queued resources.\n   *\n   * @param {function} [cb] - Optional callback that will be bound to the `complete` event.\n   * @return {this} Returns itself.\n   */\n  ;\n\n  _proto.load = function load(cb) {\n    // register complete callback if they pass one\n    if (typeof cb === 'function') {\n      this.onComplete.once(cb);\n    } // if the queue has already started we are done here\n\n\n    if (this.loading) {\n      return this;\n    }\n\n    if (this._queue.idle()) {\n      this._onStart();\n\n      this._onComplete();\n    } else {\n      // distribute progress chunks\n      var numTasks = this._queue._tasks.length;\n      var chunk = MAX_PROGRESS / numTasks;\n\n      for (var i = 0; i < this._queue._tasks.length; ++i) {\n        this._queue._tasks[i].data.progressChunk = chunk;\n      } // notify we are starting\n\n\n      this._onStart(); // start loading\n\n\n      this._queue.resume();\n    }\n\n    return this;\n  }\n  /**\n   * The number of resources to load concurrently.\n   *\n   * @member {number}\n   * @default 10\n   */\n  ;\n  /**\n   * Prepares a url for usage based on the configuration of this object\n   *\n   * @private\n   * @param {string} url - The url to prepare.\n   * @return {string} The prepared url.\n   */\n\n\n  _proto._prepareUrl = function _prepareUrl(url) {\n    var parsedUrl = parseUri(url, {\n      strictMode: true\n    });\n    var result; // absolute url, just use it as is.\n\n    if (parsedUrl.protocol || !parsedUrl.path || url.indexOf('//') === 0) {\n      result = url;\n    } // if baseUrl doesn't end in slash and url doesn't start with slash, then add a slash inbetween\n    else if (this.baseUrl.length && this.baseUrl.lastIndexOf('/') !== this.baseUrl.length - 1 && url.charAt(0) !== '/') {\n        result = this.baseUrl + \"/\" + url;\n      } else {\n        result = this.baseUrl + url;\n      } // if we need to add a default querystring, there is a bit more work\n\n\n    if (this.defaultQueryString) {\n      var hash = rgxExtractUrlHash.exec(result)[0];\n      result = result.substr(0, result.length - hash.length);\n\n      if (result.indexOf('?') !== -1) {\n        result += \"&\" + this.defaultQueryString;\n      } else {\n        result += \"?\" + this.defaultQueryString;\n      }\n\n      result += hash;\n    }\n\n    return result;\n  }\n  /**\n   * Loads a single resource.\n   *\n   * @private\n   * @param {Resource} resource - The resource to load.\n   * @param {function} dequeue - The function to call when we need to dequeue this item.\n   */\n  ;\n\n  _proto._loadResource = function _loadResource(resource, dequeue) {\n    var _this2 = this;\n\n    resource._dequeue = dequeue; // run before middleware\n\n    eachSeries(this._beforeMiddleware, function (fn, next) {\n      fn.call(_this2, resource, function () {\n        // if the before middleware marks the resource as complete,\n        // break and don't process any more before middleware\n        next(resource.isComplete ? {} : null);\n      });\n    }, function () {\n      if (resource.isComplete) {\n        _this2._onLoad(resource);\n      } else {\n        resource._onLoadBinding = resource.onComplete.once(_this2._onLoad, _this2);\n        resource.load();\n      }\n    }, true);\n  }\n  /**\n   * Called once loading has started.\n   *\n   * @private\n   */\n  ;\n\n  _proto._onStart = function _onStart() {\n    this.progress = 0;\n    this.loading = true;\n    this.onStart.dispatch(this);\n  }\n  /**\n   * Called once each resource has loaded.\n   *\n   * @private\n   */\n  ;\n\n  _proto._onComplete = function _onComplete() {\n    this.progress = MAX_PROGRESS;\n    this.loading = false;\n    this.onComplete.dispatch(this, this.resources);\n  }\n  /**\n   * Called each time a resources is loaded.\n   *\n   * @private\n   * @param {Resource} resource - The resource that was loaded\n   */\n  ;\n\n  _proto._onLoad = function _onLoad(resource) {\n    var _this3 = this;\n\n    resource._onLoadBinding = null; // remove this resource from the async queue, and add it to our list of resources that are being parsed\n\n    this._resourcesParsing.push(resource);\n\n    resource._dequeue(); // run all the after middleware for this resource\n\n\n    eachSeries(this._afterMiddleware, function (fn, next) {\n      fn.call(_this3, resource, next);\n    }, function () {\n      resource.onAfterMiddleware.dispatch(resource);\n      _this3.progress = Math.min(MAX_PROGRESS, _this3.progress + resource.progressChunk);\n\n      _this3.onProgress.dispatch(_this3, resource);\n\n      if (resource.error) {\n        _this3.onError.dispatch(resource.error, _this3, resource);\n      } else {\n        _this3.onLoad.dispatch(_this3, resource);\n      }\n\n      _this3._resourcesParsing.splice(_this3._resourcesParsing.indexOf(resource), 1); // do completion check\n\n\n      if (_this3._queue.idle() && _this3._resourcesParsing.length === 0) {\n        _this3._onComplete();\n      }\n    }, true);\n  };\n\n  _createClass(Loader, [{\n    key: \"concurrency\",\n    get: function get() {\n      return this._queue.concurrency;\n    } // eslint-disable-next-line require-jsdoc\n    ,\n    set: function set(concurrency) {\n      this._queue.concurrency = concurrency;\n    }\n  }]);\n\n  return Loader;\n}();\n/**\n * A default array of middleware to run before loading each resource.\n * Each of these middlewares are added to any new Loader instances when they are created.\n *\n * @private\n * @member {function[]}\n */\n\n\nLoader._defaultBeforeMiddleware = [];\n/**\n * A default array of middleware to run after loading each resource.\n * Each of these middlewares are added to any new Loader instances when they are created.\n *\n * @private\n * @member {function[]}\n */\n\nLoader._defaultAfterMiddleware = [];\n/**\n * Sets up a middleware function that will run *before* the\n * resource is loaded.\n *\n * @static\n * @param {function} fn - The middleware function to register.\n * @return {Loader} Returns itself.\n */\n\nLoader.pre = function LoaderPreStatic(fn) {\n  Loader._defaultBeforeMiddleware.push(fn);\n\n  return Loader;\n};\n/**\n * Sets up a middleware function that will run *after* the\n * resource is loaded.\n *\n * @static\n * @param {function} fn - The middleware function to register.\n * @return {Loader} Returns itself.\n */\n\n\nLoader.use = function LoaderUseStatic(fn) {\n  Loader._defaultAfterMiddleware.push(fn);\n\n  return Loader;\n};\n\nexport { Loader, Resource, async, encodeBinary, index as middleware };","map":{"version":3,"sources":["../src/async.js","../src/middleware/caching.js","../src/Resource.js","../src/encodeBinary.js","../src/middleware/parsing.js","../src/middleware/index.js","../src/Loader.js"],"names":["i","len","array","err","callback","setTimeout","iterator","fn","callFn","concurrency","workers","q","_tasks","saturated","unsaturated","buffer","empty","drain","error","started","paused","push","_insert","kill","unshift","process","task","worker","onlyOnce","_next","length","running","idle","pause","resume","w","data","item","_noop","arguments","cache","resource","next","useXdr","window","tempAnchor","STATUS_NONE","STATUS_OK","STATUS_EMPTY","STATUS_IE_BUG_EMPTY","STATUS_TYPE_OK","Resource","setExtensionLoadType","setExtMap","setExtensionXhrType","options","url","complete","abort","load","cb","_hasFlag","_setFlag","value","_clearEvents","clearTimeout","_finish","_loadElement","type","document","_loadSourceElement","navigator","Array","mimeTypes","_loadXhr","xhr","_loadXdr","xdr","_createSource","mime","source","_onError","event","_onProgress","_onTimeout","_xhrOnError","reqType","_xhrOnTimeout","_xhrOnAbort","_xhrOnLoad","text","status","statusType","JSON","domparser","div","_determineCrossOrigin","loc","parseUri","strictMode","samePort","protocol","_determineXhrType","_determineLoadType","_getExtension","ext","slashIndex","queryStart","hashStart","index","Math","_getMimeFromXhrType","NONE","DATA_URL","COMPLETE","LOADING","UNKNOWN","XML","IMAGE","AUDIO","VIDEO","TEXT","XHR","DEFAULT","BUFFER","BLOB","DOCUMENT","gif","png","bmp","jpg","jpeg","tif","tiff","webp","tga","svg","mp3","ogg","wav","mp4","webm","xhtml","html","htm","xml","tmx","tsx","json","txt","ttf","otf","extname","map","_keyStr","output","inx","input","bytebuffer","encodedCharIndexes","jnx","paddingBytes","Url","encodeBinary","src","MAX_PROGRESS","rgxExtractUrlHash","Loader","baseUrl","async","add","name","parent","incompleteChildren","fullChunk","eachChunk","pre","use","reset","res","numTasks","chunk","_prepareUrl","parsedUrl","result","hash","_loadResource","_onStart","_onComplete","_onLoad"],"mappings":"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","sourcesContent":["/**\n * Smaller version of the async library constructs.\n *\n * @namespace async\n */\n\n/**\n * Noop function\n *\n * @ignore\n * @function\n * @memberof async\n */\nfunction _noop() { /* empty */ }\n\n/**\n * Iterates an array in series.\n *\n * @memberof async\n * @function eachSeries\n * @param {Array.<*>} array - Array to iterate.\n * @param {function} iterator - Function to call for each element.\n * @param {function} callback - Function to call when done, or on error.\n * @param {boolean} [deferNext=false] - Break synchronous each loop by calling next with a setTimeout of 1.\n */\nexport function eachSeries(array, iterator, callback, deferNext) {\n    let i = 0;\n    const len = array.length;\n\n    (function next(err) {\n        if (err || i === len) {\n            if (callback) {\n                callback(err);\n            }\n\n            return;\n        }\n\n        if (deferNext) {\n            setTimeout(() => {\n                iterator(array[i++], next);\n            }, 1);\n        }\n        else {\n            iterator(array[i++], next);\n        }\n    })();\n}\n\n/**\n * Ensures a function is only called once.\n *\n * @ignore\n * @memberof async\n * @param {function} fn - The function to wrap.\n * @return {function} The wrapping function.\n */\nfunction onlyOnce(fn) {\n    return function onceWrapper() {\n        if (fn === null) {\n            throw new Error('Callback was already called.');\n        }\n\n        const callFn = fn;\n\n        fn = null;\n        callFn.apply(this, arguments);\n    };\n}\n\n/**\n * Async queue implementation,\n *\n * @memberof async\n * @function queue\n * @param {function} worker - The worker function to call for each task.\n * @param {number} concurrency - How many workers to run in parrallel.\n * @return {*} The async queue object.\n */\nexport function queue(worker, concurrency) {\n    if (concurrency == null) { // eslint-disable-line no-eq-null,eqeqeq\n        concurrency = 1;\n    }\n    else if (concurrency === 0) {\n        throw new Error('Concurrency must not be zero');\n    }\n\n    let workers = 0;\n    const q = {\n        _tasks: [],\n        concurrency,\n        saturated: _noop,\n        unsaturated: _noop,\n        buffer: concurrency / 4,\n        empty: _noop,\n        drain: _noop,\n        error: _noop,\n        started: false,\n        paused: false,\n        push(data, callback) {\n            _insert(data, false, callback);\n        },\n        kill() {\n            workers = 0;\n            q.drain = _noop;\n            q.started = false;\n            q._tasks = [];\n        },\n        unshift(data, callback) {\n            _insert(data, true, callback);\n        },\n        process() {\n            while (!q.paused && workers < q.concurrency && q._tasks.length) {\n                const task = q._tasks.shift();\n\n                if (q._tasks.length === 0) {\n                    q.empty();\n                }\n\n                workers += 1;\n\n                if (workers === q.concurrency) {\n                    q.saturated();\n                }\n\n                worker(task.data, onlyOnce(_next(task)));\n            }\n        },\n        length() {\n            return q._tasks.length;\n        },\n        running() {\n            return workers;\n        },\n        idle() {\n            return q._tasks.length + workers === 0;\n        },\n        pause() {\n            if (q.paused === true) {\n                return;\n            }\n\n            q.paused = true;\n        },\n        resume() {\n            if (q.paused === false) {\n                return;\n            }\n\n            q.paused = false;\n\n            // Need to call q.process once per concurrent\n            // worker to preserve full concurrency after pause\n            for (let w = 1; w <= q.concurrency; w++) {\n                q.process();\n            }\n        },\n    };\n\n    function _insert(data, insertAtFront, callback) {\n        if (callback != null && typeof callback !== 'function') { // eslint-disable-line no-eq-null,eqeqeq\n            throw new Error('task callback must be a function');\n        }\n\n        q.started = true;\n\n        if (data == null && q.idle()) { // eslint-disable-line no-eq-null,eqeqeq\n            // call drain immediately if there are no tasks\n            setTimeout(() => q.drain(), 1);\n\n            return;\n        }\n\n        const item = {\n            data,\n            callback: typeof callback === 'function' ? callback : _noop,\n        };\n\n        if (insertAtFront) {\n            q._tasks.unshift(item);\n        }\n        else {\n            q._tasks.push(item);\n        }\n\n        setTimeout(() => q.process(), 1);\n    }\n\n    function _next(task) {\n        return function next() {\n            workers -= 1;\n\n            task.callback.apply(task, arguments);\n\n            if (arguments[0] != null) { // eslint-disable-line no-eq-null,eqeqeq\n                q.error(arguments[0], task.data);\n            }\n\n            if (workers <= (q.concurrency - q.buffer)) {\n                q.unsaturated();\n            }\n\n            if (q.idle()) {\n                q.drain();\n            }\n\n            q.process();\n        };\n    }\n\n    return q;\n}\n","// a simple in-memory cache for resources\nconst cache = {};\n\n/**\n * A simple in-memory cache for resource.\n *\n * @memberof middleware\n * @function caching\n * @example\n * import { Loader, middleware } from 'resource-loader';\n * const loader = new Loader();\n * loader.use(middleware.caching);\n * @param {Resource} resource - Current Resource\n * @param {function} next - Callback when complete\n */\nexport function caching(resource, next) {\n    // if cached, then set data and complete the resource\n    if (cache[resource.url]) {\n        resource.data = cache[resource.url];\n        resource.complete(); // marks resource load complete and stops processing before middlewares\n    }\n    // if not cached, wait for complete and store it in the cache.\n    else {\n        resource.onComplete.once(() => (cache[this.url] = this.data));\n    }\n\n    next();\n}\n","import parseUri from 'parse-uri';\nimport Signal from 'mini-signals';\n\n// tests if CORS is supported in XHR, if not we need to use XDR\nconst useXdr = !!(window.XDomainRequest && !('withCredentials' in (new XMLHttpRequest())));\nlet tempAnchor = null;\n\n// some status constants\nconst STATUS_NONE = 0;\nconst STATUS_OK = 200;\nconst STATUS_EMPTY = 204;\nconst STATUS_IE_BUG_EMPTY = 1223;\nconst STATUS_TYPE_OK = 2;\n\n// noop\nfunction _noop() { /* empty */ }\n\n/**\n * Manages the state and loading of a resource and all child resources.\n *\n * @class\n */\nclass Resource {\n    /**\n     * Sets the load type to be used for a specific extension.\n     *\n     * @static\n     * @param {string} extname - The extension to set the type for, e.g. \"png\" or \"fnt\"\n     * @param {Resource.LOAD_TYPE} loadType - The load type to set it to.\n     */\n    static setExtensionLoadType(extname, loadType) {\n        setExtMap(Resource._loadTypeMap, extname, loadType);\n    }\n\n    /**\n     * Sets the load type to be used for a specific extension.\n     *\n     * @static\n     * @param {string} extname - The extension to set the type for, e.g. \"png\" or \"fnt\"\n     * @param {Resource.XHR_RESPONSE_TYPE} xhrType - The xhr type to set it to.\n     */\n    static setExtensionXhrType(extname, xhrType) {\n        setExtMap(Resource._xhrTypeMap, extname, xhrType);\n    }\n\n    /**\n     * @param {string} name - The name of the resource to load.\n     * @param {string|string[]} url - The url for this resource, for audio/video loads you can pass\n     *      an array of sources.\n     * @param {object} [options] - The options for the load.\n     * @param {string|boolean} [options.crossOrigin] - Is this request cross-origin? Default is to\n     *      determine automatically.\n     * @param {number} [options.timeout=0] - A timeout in milliseconds for the load. If the load takes\n     *      longer than this time it is cancelled and the load is considered a failure. If this value is\n     *      set to `0` then there is no explicit timeout.\n     * @param {Resource.LOAD_TYPE} [options.loadType=Resource.LOAD_TYPE.XHR] - How should this resource\n     *      be loaded?\n     * @param {Resource.XHR_RESPONSE_TYPE} [options.xhrType=Resource.XHR_RESPONSE_TYPE.DEFAULT] - How\n     *      should the data being loaded be interpreted when using XHR?\n     * @param {Resource.IMetadata} [options.metadata] - Extra configuration for middleware and the Resource object.\n     */\n    constructor(name, url, options) {\n        if (typeof name !== 'string' || typeof url !== 'string') {\n            throw new Error('Both name and url are required for constructing a resource.');\n        }\n\n        options = options || {};\n\n        /**\n         * The state flags of this resource.\n         *\n         * @private\n         * @member {number}\n         */\n        this._flags = 0;\n\n        // set data url flag, needs to be set early for some _determineX checks to work.\n        this._setFlag(Resource.STATUS_FLAGS.DATA_URL, url.indexOf('data:') === 0);\n\n        /**\n         * The name of this resource.\n         *\n         * @readonly\n         * @member {string}\n         */\n        this.name = name;\n\n        /**\n         * The url used to load this resource.\n         *\n         * @readonly\n         * @member {string}\n         */\n        this.url = url;\n\n        /**\n         * The extension used to load this resource.\n         *\n         * @readonly\n         * @member {string}\n         */\n        this.extension = this._getExtension();\n\n        /**\n         * The data that was loaded by the resource.\n         *\n         * @member {any}\n         */\n        this.data = null;\n\n        /**\n         * Is this request cross-origin? If unset, determined automatically.\n         *\n         * @member {string}\n         */\n        this.crossOrigin = options.crossOrigin === true ? 'anonymous' : options.crossOrigin;\n\n        /**\n         * A timeout in milliseconds for the load. If the load takes longer than this time\n         * it is cancelled and the load is considered a failure. If this value is set to `0`\n         * then there is no explicit timeout.\n         *\n         * @member {number}\n         */\n        this.timeout = options.timeout || 0;\n\n        /**\n         * The method of loading to use for this resource.\n         *\n         * @member {Resource.LOAD_TYPE}\n         */\n        this.loadType = options.loadType || this._determineLoadType();\n\n        /**\n         * The type used to load the resource via XHR. If unset, determined automatically.\n         *\n         * @member {string}\n         */\n        this.xhrType = options.xhrType;\n\n        /**\n         * Extra info for middleware, and controlling specifics about how the resource loads.\n         *\n         * Note that if you pass in a `loadElement`, the Resource class takes ownership of it.\n         * Meaning it will modify it as it sees fit.\n         *\n         * @member {Resource.IMetadata}\n         */\n        this.metadata = options.metadata || {};\n\n        /**\n         * The error that occurred while loading (if any).\n         *\n         * @readonly\n         * @member {Error}\n         */\n        this.error = null;\n\n        /**\n         * The XHR object that was used to load this resource. This is only set\n         * when `loadType` is `Resource.LOAD_TYPE.XHR`.\n         *\n         * @readonly\n         * @member {XMLHttpRequest}\n         */\n        this.xhr = null;\n\n        /**\n         * The child resources this resource owns.\n         *\n         * @readonly\n         * @member {Resource[]}\n         */\n        this.children = [];\n\n        /**\n         * The resource type.\n         *\n         * @readonly\n         * @member {Resource.TYPE}\n         */\n        this.type = Resource.TYPE.UNKNOWN;\n\n        /**\n         * The progress chunk owned by this resource.\n         *\n         * @readonly\n         * @member {number}\n         */\n        this.progressChunk = 0;\n\n        /**\n         * The `dequeue` method that will be used a storage place for the async queue dequeue method\n         * used privately by the loader.\n         *\n         * @private\n         * @member {function}\n         */\n        this._dequeue = _noop;\n\n        /**\n         * Used a storage place for the on load binding used privately by the loader.\n         *\n         * @private\n         * @member {function}\n         */\n        this._onLoadBinding = null;\n\n        /**\n         * The timer for element loads to check if they timeout.\n         *\n         * @private\n         * @member {number}\n         */\n        this._elementTimer = 0;\n\n        /**\n         * The `complete` function bound to this resource's context.\n         *\n         * @private\n         * @member {function}\n         */\n        this._boundComplete = this.complete.bind(this);\n\n        /**\n         * The `_onError` function bound to this resource's context.\n         *\n         * @private\n         * @member {function}\n         */\n        this._boundOnError = this._onError.bind(this);\n\n        /**\n         * The `_onProgress` function bound to this resource's context.\n         *\n         * @private\n         * @member {function}\n         */\n        this._boundOnProgress = this._onProgress.bind(this);\n\n        /**\n         * The `_onTimeout` function bound to this resource's context.\n         *\n         * @private\n         * @member {function}\n         */\n        this._boundOnTimeout = this._onTimeout.bind(this);\n\n        // xhr callbacks\n        this._boundXhrOnError = this._xhrOnError.bind(this);\n        this._boundXhrOnTimeout = this._xhrOnTimeout.bind(this);\n        this._boundXhrOnAbort = this._xhrOnAbort.bind(this);\n        this._boundXhrOnLoad = this._xhrOnLoad.bind(this);\n\n        /**\n         * Dispatched when the resource beings to load.\n         *\n         * The callback looks like {@link Resource.OnStartSignal}.\n         *\n         * @member {Signal<Resource.OnStartSignal>}\n         */\n        this.onStart = new Signal();\n\n        /**\n         * Dispatched each time progress of this resource load updates.\n         * Not all resources types and loader systems can support this event\n         * so sometimes it may not be available. If the resource\n         * is being loaded on a modern browser, using XHR, and the remote server\n         * properly sets Content-Length headers, then this will be available.\n         *\n         * The callback looks like {@link Resource.OnProgressSignal}.\n         *\n         * @member {Signal<Resource.OnProgressSignal>}\n         */\n        this.onProgress = new Signal();\n\n        /**\n         * Dispatched once this resource has loaded, if there was an error it will\n         * be in the `error` property.\n         *\n         * The callback looks like {@link Resource.OnCompleteSignal}.\n         *\n         * @member {Signal<Resource.OnCompleteSignal>}\n         */\n        this.onComplete = new Signal();\n\n        /**\n         * Dispatched after this resource has had all the *after* middleware run on it.\n         *\n         * The callback looks like {@link Resource.OnCompleteSignal}.\n         *\n         * @member {Signal<Resource.OnCompleteSignal>}\n         */\n        this.onAfterMiddleware = new Signal();\n    }\n\n    /**\n     * When the resource starts to load.\n     *\n     * @memberof Resource\n     * @callback OnStartSignal\n     * @param {Resource} resource - The resource that the event happened on.\n     */\n\n    /**\n     * When the resource reports loading progress.\n     *\n     * @memberof Resource\n     * @callback OnProgressSignal\n     * @param {Resource} resource - The resource that the event happened on.\n     * @param {number} percentage - The progress of the load in the range [0, 1].\n     */\n\n    /**\n     * When the resource finishes loading.\n     *\n     * @memberof Resource\n     * @callback OnCompleteSignal\n     * @param {Resource} resource - The resource that the event happened on.\n     */\n\n    /**\n     * @memberof Resource\n     * @typedef {object} IMetadata\n     * @property {HTMLImageElement|HTMLAudioElement|HTMLVideoElement} [loadElement=null] - The\n     *      element to use for loading, instead of creating one.\n     * @property {boolean} [skipSource=false] - Skips adding source(s) to the load element. This\n     *      is useful if you want to pass in a `loadElement` that you already added load sources to.\n     * @property {string|string[]} [mimeType] - The mime type to use for the source element\n     *      of a video/audio elment. If the urls are an array, you can pass this as an array as well\n     *      where each index is the mime type to use for the corresponding url index.\n     */\n\n    /**\n     * Stores whether or not this url is a data url.\n     *\n     * @readonly\n     * @member {boolean}\n     */\n    get isDataUrl() {\n        return this._hasFlag(Resource.STATUS_FLAGS.DATA_URL);\n    }\n\n    /**\n     * Describes if this resource has finished loading. Is true when the resource has completely\n     * loaded.\n     *\n     * @readonly\n     * @member {boolean}\n     */\n    get isComplete() {\n        return this._hasFlag(Resource.STATUS_FLAGS.COMPLETE);\n    }\n\n    /**\n     * Describes if this resource is currently loading. Is true when the resource starts loading,\n     * and is false again when complete.\n     *\n     * @readonly\n     * @member {boolean}\n     */\n    get isLoading() {\n        return this._hasFlag(Resource.STATUS_FLAGS.LOADING);\n    }\n\n    /**\n     * Marks the resource as complete.\n     *\n     */\n    complete() {\n        this._clearEvents();\n        this._finish();\n    }\n\n    /**\n     * Aborts the loading of this resource, with an optional message.\n     *\n     * @param {string} message - The message to use for the error\n     */\n    abort(message) {\n        // abort can be called multiple times, ignore subsequent calls.\n        if (this.error) {\n            return;\n        }\n\n        // store error\n        this.error = new Error(message);\n\n        // clear events before calling aborts\n        this._clearEvents();\n\n        // abort the actual loading\n        if (this.xhr) {\n            this.xhr.abort();\n        }\n        else if (this.xdr) {\n            this.xdr.abort();\n        }\n        else if (this.data) {\n            // single source\n            if (this.data.src) {\n                this.data.src = Resource.EMPTY_GIF;\n            }\n            // multi-source\n            else {\n                while (this.data.firstChild) {\n                    this.data.removeChild(this.data.firstChild);\n                }\n            }\n        }\n\n        // done now.\n        this._finish();\n    }\n\n    /**\n     * Kicks off loading of this resource. This method is asynchronous.\n     *\n     * @param {Resource.OnCompleteSignal} [cb] - Optional callback to call once the resource is loaded.\n     */\n    load(cb) {\n        if (this.isLoading) {\n            return;\n        }\n\n        if (this.isComplete) {\n            if (cb) {\n                setTimeout(() => cb(this), 1);\n            }\n\n            return;\n        }\n        else if (cb) {\n            this.onComplete.once(cb);\n        }\n\n        this._setFlag(Resource.STATUS_FLAGS.LOADING, true);\n\n        this.onStart.dispatch(this);\n\n        // if unset, determine the value\n        if (this.crossOrigin === false || typeof this.crossOrigin !== 'string') {\n            this.crossOrigin = this._determineCrossOrigin(this.url);\n        }\n\n        switch (this.loadType) {\n            case Resource.LOAD_TYPE.IMAGE:\n                this.type = Resource.TYPE.IMAGE;\n                this._loadElement('image');\n                break;\n\n            case Resource.LOAD_TYPE.AUDIO:\n                this.type = Resource.TYPE.AUDIO;\n                this._loadSourceElement('audio');\n                break;\n\n            case Resource.LOAD_TYPE.VIDEO:\n                this.type = Resource.TYPE.VIDEO;\n                this._loadSourceElement('video');\n                break;\n\n            case Resource.LOAD_TYPE.XHR:\n                /* falls through */\n            default:\n                if (useXdr && this.crossOrigin) {\n                    this._loadXdr();\n                }\n                else {\n                    this._loadXhr();\n                }\n                break;\n        }\n    }\n\n    /**\n     * Checks if the flag is set.\n     *\n     * @private\n     * @param {number} flag - The flag to check.\n     * @return {boolean} True if the flag is set.\n     */\n    _hasFlag(flag) {\n        return (this._flags & flag) !== 0;\n    }\n\n    /**\n     * (Un)Sets the flag.\n     *\n     * @private\n     * @param {number} flag - The flag to (un)set.\n     * @param {boolean} value - Whether to set or (un)set the flag.\n     */\n    _setFlag(flag, value) {\n        this._flags = value ? (this._flags | flag) : (this._flags & ~flag);\n    }\n\n    /**\n     * Clears all the events from the underlying loading source.\n     *\n     * @private\n     */\n    _clearEvents() {\n        clearTimeout(this._elementTimer);\n\n        if (this.data && this.data.removeEventListener) {\n            this.data.removeEventListener('error', this._boundOnError, false);\n            this.data.removeEventListener('load', this._boundComplete, false);\n            this.data.removeEventListener('progress', this._boundOnProgress, false);\n            this.data.removeEventListener('canplaythrough', this._boundComplete, false);\n        }\n\n        if (this.xhr) {\n            if (this.xhr.removeEventListener) {\n                this.xhr.removeEventListener('error', this._boundXhrOnError, false);\n                this.xhr.removeEventListener('timeout', this._boundXhrOnTimeout, false);\n                this.xhr.removeEventListener('abort', this._boundXhrOnAbort, false);\n                this.xhr.removeEventListener('progress', this._boundOnProgress, false);\n                this.xhr.removeEventListener('load', this._boundXhrOnLoad, false);\n            }\n            else {\n                this.xhr.onerror = null;\n                this.xhr.ontimeout = null;\n                this.xhr.onprogress = null;\n                this.xhr.onload = null;\n            }\n        }\n    }\n\n    /**\n     * Finalizes the load.\n     *\n     * @private\n     */\n    _finish() {\n        if (this.isComplete) {\n            throw new Error('Complete called again for an already completed resource.');\n        }\n\n        this._setFlag(Resource.STATUS_FLAGS.COMPLETE, true);\n        this._setFlag(Resource.STATUS_FLAGS.LOADING, false);\n\n        this.onComplete.dispatch(this);\n    }\n\n    /**\n     * Loads this resources using an element that has a single source,\n     * like an HTMLImageElement.\n     *\n     * @private\n     * @param {string} type - The type of element to use.\n     */\n    _loadElement(type) {\n        if (this.metadata.loadElement) {\n            this.data = this.metadata.loadElement;\n        }\n        else if (type === 'image' && typeof window.Image !== 'undefined') {\n            this.data = new Image();\n        }\n        else {\n            this.data = document.createElement(type);\n        }\n\n        if (this.crossOrigin) {\n            this.data.crossOrigin = this.crossOrigin;\n        }\n\n        if (!this.metadata.skipSource) {\n            this.data.src = this.url;\n        }\n\n        this.data.addEventListener('error', this._boundOnError, false);\n        this.data.addEventListener('load', this._boundComplete, false);\n        this.data.addEventListener('progress', this._boundOnProgress, false);\n\n        if (this.timeout) {\n            this._elementTimer = setTimeout(this._boundOnTimeout, this.timeout);\n        }\n    }\n\n    /**\n     * Loads this resources using an element that has multiple sources,\n     * like an HTMLAudioElement or HTMLVideoElement.\n     *\n     * @private\n     * @param {string} type - The type of element to use.\n     */\n    _loadSourceElement(type) {\n        if (this.metadata.loadElement) {\n            this.data = this.metadata.loadElement;\n        }\n        else if (type === 'audio' && typeof window.Audio !== 'undefined') {\n            this.data = new Audio();\n        }\n        else {\n            this.data = document.createElement(type);\n        }\n\n        if (this.data === null) {\n            this.abort(`Unsupported element: ${type}`);\n\n            return;\n        }\n\n        if (this.crossOrigin) {\n            this.data.crossOrigin = this.crossOrigin;\n        }\n\n        if (!this.metadata.skipSource) {\n            // support for CocoonJS Canvas+ runtime, lacks document.createElement('source')\n            if (navigator.isCocoonJS) {\n                this.data.src = Array.isArray(this.url) ? this.url[0] : this.url;\n            }\n            else if (Array.isArray(this.url)) {\n                const mimeTypes = this.metadata.mimeType;\n\n                for (let i = 0; i < this.url.length; ++i) {\n                    this.data.appendChild(\n                        this._createSource(type, this.url[i], Array.isArray(mimeTypes) ? mimeTypes[i] : mimeTypes)\n                    );\n                }\n            }\n            else {\n                const mimeTypes = this.metadata.mimeType;\n\n                this.data.appendChild(\n                    this._createSource(type, this.url, Array.isArray(mimeTypes) ? mimeTypes[0] : mimeTypes)\n                );\n            }\n        }\n\n        this.data.addEventListener('error', this._boundOnError, false);\n        this.data.addEventListener('load', this._boundComplete, false);\n        this.data.addEventListener('progress', this._boundOnProgress, false);\n        this.data.addEventListener('canplaythrough', this._boundComplete, false);\n\n        this.data.load();\n\n        if (this.timeout) {\n            this._elementTimer = setTimeout(this._boundOnTimeout, this.timeout);\n        }\n    }\n\n    /**\n     * Loads this resources using an XMLHttpRequest.\n     *\n     * @private\n     */\n    _loadXhr() {\n        // if unset, determine the value\n        if (typeof this.xhrType !== 'string') {\n            this.xhrType = this._determineXhrType();\n        }\n\n        const xhr = this.xhr = new XMLHttpRequest();\n\n        // set the request type and url\n        xhr.open('GET', this.url, true);\n\n        xhr.timeout = this.timeout;\n\n        // load json as text and parse it ourselves. We do this because some browsers\n        // *cough* safari *cough* can't deal with it.\n        if (this.xhrType === Resource.XHR_RESPONSE_TYPE.JSON || this.xhrType === Resource.XHR_RESPONSE_TYPE.DOCUMENT) {\n            xhr.responseType = Resource.XHR_RESPONSE_TYPE.TEXT;\n        }\n        else {\n            xhr.responseType = this.xhrType;\n        }\n\n        xhr.addEventListener('error', this._boundXhrOnError, false);\n        xhr.addEventListener('timeout', this._boundXhrOnTimeout, false);\n        xhr.addEventListener('abort', this._boundXhrOnAbort, false);\n        xhr.addEventListener('progress', this._boundOnProgress, false);\n        xhr.addEventListener('load', this._boundXhrOnLoad, false);\n\n        xhr.send();\n    }\n\n    /**\n     * Loads this resources using an XDomainRequest. This is here because we need to support IE9 (gross).\n     *\n     * @private\n     */\n    _loadXdr() {\n        // if unset, determine the value\n        if (typeof this.xhrType !== 'string') {\n            this.xhrType = this._determineXhrType();\n        }\n\n        const xdr = this.xhr = new XDomainRequest(); // eslint-disable-line no-undef\n\n        // XDomainRequest has a few quirks. Occasionally it will abort requests\n        // A way to avoid this is to make sure ALL callbacks are set even if not used\n        // More info here: http://stackoverflow.com/questions/15786966/xdomainrequest-aborts-post-on-ie-9\n        xdr.timeout = this.timeout || 5000; // XDR needs a timeout value or it breaks in IE9\n\n        xdr.onerror = this._boundXhrOnError;\n        xdr.ontimeout = this._boundXhrOnTimeout;\n        xdr.onprogress = this._boundOnProgress;\n        xdr.onload = this._boundXhrOnLoad;\n\n        xdr.open('GET', this.url, true);\n\n        // Note: The xdr.send() call is wrapped in a timeout to prevent an\n        // issue with the interface where some requests are lost if multiple\n        // XDomainRequests are being sent at the same time.\n        // Some info here: https://github.com/photonstorm/phaser/issues/1248\n        setTimeout(() => xdr.send(), 1);\n    }\n\n    /**\n     * Creates a source used in loading via an element.\n     *\n     * @private\n     * @param {string} type - The element type (video or audio).\n     * @param {string} url - The source URL to load from.\n     * @param {string} [mime] - The mime type of the video\n     * @return {HTMLSourceElement} The source element.\n     */\n    _createSource(type, url, mime) {\n        if (!mime) {\n            mime = `${type}/${this._getExtension(url)}`;\n        }\n\n        const source = document.createElement('source');\n\n        source.src = url;\n        source.type = mime;\n\n        return source;\n    }\n\n    /**\n     * Called if a load errors out.\n     *\n     * @param {Event} event - The error event from the element that emits it.\n     * @private\n     */\n    _onError(event) {\n        this.abort(`Failed to load element using: ${event.target.nodeName}`);\n    }\n\n    /**\n     * Called if a load progress event fires for an element or xhr/xdr.\n     *\n     * @private\n     * @param {XMLHttpRequestProgressEvent|Event} event - Progress event.\n     */\n    _onProgress(event) {\n        if (event && event.lengthComputable) {\n            this.onProgress.dispatch(this, event.loaded / event.total);\n        }\n    }\n\n    /**\n     * Called if a timeout event fires for an element.\n     *\n     * @private\n     */\n    _onTimeout() {\n        this.abort(`Load timed out.`);\n    }\n\n    /**\n     * Called if an error event fires for xhr/xdr.\n     *\n     * @private\n     */\n    _xhrOnError() {\n        const xhr = this.xhr;\n\n        this.abort(`${reqType(xhr)} Request failed. Status: ${xhr.status}, text: \"${xhr.statusText}\"`);\n    }\n\n    /**\n     * Called if an error event fires for xhr/xdr.\n     *\n     * @private\n     */\n    _xhrOnTimeout() {\n        const xhr = this.xhr;\n\n        this.abort(`${reqType(xhr)} Request timed out.`);\n    }\n\n    /**\n     * Called if an abort event fires for xhr/xdr.\n     *\n     * @private\n     */\n    _xhrOnAbort() {\n        const xhr = this.xhr;\n\n        this.abort(`${reqType(xhr)} Request was aborted by the user.`);\n    }\n\n    /**\n     * Called when data successfully loads from an xhr/xdr request.\n     *\n     * @private\n     * @param {XMLHttpRequestLoadEvent|Event} event - Load event\n     */\n    _xhrOnLoad() {\n        const xhr = this.xhr;\n        let text = '';\n        let status = typeof xhr.status === 'undefined' ? STATUS_OK : xhr.status; // XDR has no `.status`, assume 200.\n\n        // responseText is accessible only if responseType is '' or 'text' and on older browsers\n        if (xhr.responseType === '' || xhr.responseType === 'text' || typeof xhr.responseType === 'undefined') {\n            text = xhr.responseText;\n        }\n\n        // status can be 0 when using the `file://` protocol so we also check if a response is set.\n        // If it has a response, we assume 200; otherwise a 0 status code with no contents is an aborted request.\n        if (status === STATUS_NONE && (text.length > 0 || xhr.responseType === Resource.XHR_RESPONSE_TYPE.BUFFER)) {\n            status = STATUS_OK;\n        }\n        // handle IE9 bug: http://stackoverflow.com/questions/10046972/msie-returns-status-code-of-1223-for-ajax-request\n        else if (status === STATUS_IE_BUG_EMPTY) {\n            status = STATUS_EMPTY;\n        }\n\n        const statusType = (status / 100) | 0;\n\n        if (statusType === STATUS_TYPE_OK) {\n            // if text, just return it\n            if (this.xhrType === Resource.XHR_RESPONSE_TYPE.TEXT) {\n                this.data = text;\n                this.type = Resource.TYPE.TEXT;\n            }\n            // if json, parse into json object\n            else if (this.xhrType === Resource.XHR_RESPONSE_TYPE.JSON) {\n                try {\n                    this.data = JSON.parse(text);\n                    this.type = Resource.TYPE.JSON;\n                }\n                catch (e) {\n                    this.abort(`Error trying to parse loaded json: ${e}`);\n\n                    return;\n                }\n            }\n            // if xml, parse into an xml document or div element\n            else if (this.xhrType === Resource.XHR_RESPONSE_TYPE.DOCUMENT) {\n                try {\n                    if (window.DOMParser) {\n                        const domparser = new DOMParser();\n\n                        this.data = domparser.parseFromString(text, 'text/xml');\n                    }\n                    else {\n                        const div = document.createElement('div');\n\n                        div.innerHTML = text;\n\n                        this.data = div;\n                    }\n\n                    this.type = Resource.TYPE.XML;\n                }\n                catch (e) {\n                    this.abort(`Error trying to parse loaded xml: ${e}`);\n\n                    return;\n                }\n            }\n            // other types just return the response\n            else {\n                this.data = xhr.response || text;\n            }\n        }\n        else {\n            this.abort(`[${xhr.status}] ${xhr.statusText}: ${xhr.responseURL}`);\n\n            return;\n        }\n\n        this.complete();\n    }\n\n    /**\n     * Sets the `crossOrigin` property for this resource based on if the url\n     * for this resource is cross-origin. If crossOrigin was manually set, this\n     * function does nothing.\n     *\n     * @private\n     * @param {string} url - The url to test.\n     * @param {object} [loc=window.location] - The location object to test against.\n     * @return {string} The crossOrigin value to use (or empty string for none).\n     */\n    _determineCrossOrigin(url, loc) {\n        // data: and javascript: urls are considered same-origin\n        if (url.indexOf('data:') === 0) {\n            return '';\n        }\n\n        // A sandboxed iframe without the 'allow-same-origin' attribute will have a special\n        // origin designed not to match window.location.origin, and will always require\n        // crossOrigin requests regardless of whether the location matches.\n        if (window.origin !== window.location.origin) {\n            return 'anonymous';\n        }\n\n        // default is window.location\n        loc = loc || window.location;\n\n        if (!tempAnchor) {\n            tempAnchor = document.createElement('a');\n        }\n\n        // let the browser determine the full href for the url of this resource and then\n        // parse with the node url lib, we can't use the properties of the anchor element\n        // because they don't work in IE9 :(\n        tempAnchor.href = url;\n        url = parseUri(tempAnchor.href, { strictMode: true });\n\n        const samePort = (!url.port && loc.port === '') || (url.port === loc.port);\n        const protocol = url.protocol ? `${url.protocol}:` : '';\n\n        // if cross origin\n        if (url.host !== loc.hostname || !samePort || protocol !== loc.protocol) {\n            return 'anonymous';\n        }\n\n        return '';\n    }\n\n    /**\n     * Determines the responseType of an XHR request based on the extension of the\n     * resource being loaded.\n     *\n     * @private\n     * @return {Resource.XHR_RESPONSE_TYPE} The responseType to use.\n     */\n    _determineXhrType() {\n        return Resource._xhrTypeMap[this.extension] || Resource.XHR_RESPONSE_TYPE.TEXT;\n    }\n\n    /**\n     * Determines the loadType of a resource based on the extension of the\n     * resource being loaded.\n     *\n     * @private\n     * @return {Resource.LOAD_TYPE} The loadType to use.\n     */\n    _determineLoadType() {\n        return Resource._loadTypeMap[this.extension] || Resource.LOAD_TYPE.XHR;\n    }\n\n    /**\n     * Extracts the extension (sans '.') of the file being loaded by the resource.\n     *\n     * @private\n     * @return {string} The extension.\n     */\n    _getExtension() {\n        let url = this.url;\n        let ext = '';\n\n        if (this.isDataUrl) {\n            const slashIndex = url.indexOf('/');\n\n            ext = url.substring(slashIndex + 1, url.indexOf(';', slashIndex));\n        }\n        else {\n            const queryStart = url.indexOf('?');\n            const hashStart = url.indexOf('#');\n            const index = Math.min(\n                queryStart > -1 ? queryStart : url.length,\n                hashStart > -1 ? hashStart : url.length\n            );\n\n            url = url.substring(0, index);\n            ext = url.substring(url.lastIndexOf('.') + 1);\n        }\n\n        return ext.toLowerCase();\n    }\n\n    /**\n     * Determines the mime type of an XHR request based on the responseType of\n     * resource being loaded.\n     *\n     * @private\n     * @param {Resource.XHR_RESPONSE_TYPE} type - The type to get a mime type for.\n     * @return {string} The mime type to use.\n     */\n    _getMimeFromXhrType(type) {\n        switch (type) {\n            case Resource.XHR_RESPONSE_TYPE.BUFFER:\n                return 'application/octet-binary';\n\n            case Resource.XHR_RESPONSE_TYPE.BLOB:\n                return 'application/blob';\n\n            case Resource.XHR_RESPONSE_TYPE.DOCUMENT:\n                return 'application/xml';\n\n            case Resource.XHR_RESPONSE_TYPE.JSON:\n                return 'application/json';\n\n            case Resource.XHR_RESPONSE_TYPE.DEFAULT:\n            case Resource.XHR_RESPONSE_TYPE.TEXT:\n                /* falls through */\n            default:\n                return 'text/plain';\n        }\n    }\n}\n\n/**\n * The types of resources a resource could represent.\n *\n * @static\n * @readonly\n * @enum {number}\n */\nResource.STATUS_FLAGS = {\n    NONE:       0,\n    DATA_URL:   (1 << 0),\n    COMPLETE:   (1 << 1),\n    LOADING:    (1 << 2),\n};\n\n/**\n * The types of resources a resource could represent.\n *\n * @static\n * @readonly\n * @enum {number}\n */\nResource.TYPE = {\n    UNKNOWN:    0,\n    JSON:       1,\n    XML:        2,\n    IMAGE:      3,\n    AUDIO:      4,\n    VIDEO:      5,\n    TEXT:       6,\n};\n\n/**\n * The types of loading a resource can use.\n *\n * @static\n * @readonly\n * @enum {number}\n */\nResource.LOAD_TYPE = {\n    /** Uses XMLHttpRequest to load the resource. */\n    XHR:    1,\n    /** Uses an `Image` object to load the resource. */\n    IMAGE:  2,\n    /** Uses an `Audio` object to load the resource. */\n    AUDIO:  3,\n    /** Uses a `Video` object to load the resource. */\n    VIDEO:  4,\n};\n\n/**\n * The XHR ready states, used internally.\n *\n * @static\n * @readonly\n * @enum {string}\n */\nResource.XHR_RESPONSE_TYPE = {\n    /** string */\n    DEFAULT:    'text',\n    /** ArrayBuffer */\n    BUFFER:     'arraybuffer',\n    /** Blob */\n    BLOB:       'blob',\n    /** Document */\n    DOCUMENT:   'document',\n    /** Object */\n    JSON:       'json',\n    /** String */\n    TEXT:       'text',\n};\n\nResource._loadTypeMap = {\n    // images\n    gif:        Resource.LOAD_TYPE.IMAGE,\n    png:        Resource.LOAD_TYPE.IMAGE,\n    bmp:        Resource.LOAD_TYPE.IMAGE,\n    jpg:        Resource.LOAD_TYPE.IMAGE,\n    jpeg:       Resource.LOAD_TYPE.IMAGE,\n    tif:        Resource.LOAD_TYPE.IMAGE,\n    tiff:       Resource.LOAD_TYPE.IMAGE,\n    webp:       Resource.LOAD_TYPE.IMAGE,\n    tga:        Resource.LOAD_TYPE.IMAGE,\n    svg:        Resource.LOAD_TYPE.IMAGE,\n    'svg+xml':  Resource.LOAD_TYPE.IMAGE, // for SVG data urls\n\n    // audio\n    mp3:        Resource.LOAD_TYPE.AUDIO,\n    ogg:        Resource.LOAD_TYPE.AUDIO,\n    wav:        Resource.LOAD_TYPE.AUDIO,\n\n    // videos\n    mp4:        Resource.LOAD_TYPE.VIDEO,\n    webm:       Resource.LOAD_TYPE.VIDEO,\n};\n\nResource._xhrTypeMap = {\n    // xml\n    xhtml:      Resource.XHR_RESPONSE_TYPE.DOCUMENT,\n    html:       Resource.XHR_RESPONSE_TYPE.DOCUMENT,\n    htm:        Resource.XHR_RESPONSE_TYPE.DOCUMENT,\n    xml:        Resource.XHR_RESPONSE_TYPE.DOCUMENT,\n    tmx:        Resource.XHR_RESPONSE_TYPE.DOCUMENT,\n    svg:        Resource.XHR_RESPONSE_TYPE.DOCUMENT,\n\n    // This was added to handle Tiled Tileset XML, but .tsx is also a TypeScript React Component.\n    // Since it is way less likely for people to be loading TypeScript files instead of Tiled files,\n    // this should probably be fine.\n    tsx:        Resource.XHR_RESPONSE_TYPE.DOCUMENT,\n\n    // images\n    gif:        Resource.XHR_RESPONSE_TYPE.BLOB,\n    png:        Resource.XHR_RESPONSE_TYPE.BLOB,\n    bmp:        Resource.XHR_RESPONSE_TYPE.BLOB,\n    jpg:        Resource.XHR_RESPONSE_TYPE.BLOB,\n    jpeg:       Resource.XHR_RESPONSE_TYPE.BLOB,\n    tif:        Resource.XHR_RESPONSE_TYPE.BLOB,\n    tiff:       Resource.XHR_RESPONSE_TYPE.BLOB,\n    webp:       Resource.XHR_RESPONSE_TYPE.BLOB,\n    tga:        Resource.XHR_RESPONSE_TYPE.BLOB,\n\n    // json\n    json:       Resource.XHR_RESPONSE_TYPE.JSON,\n\n    // text\n    text:       Resource.XHR_RESPONSE_TYPE.TEXT,\n    txt:        Resource.XHR_RESPONSE_TYPE.TEXT,\n\n    // fonts\n    ttf:        Resource.XHR_RESPONSE_TYPE.BUFFER,\n    otf:        Resource.XHR_RESPONSE_TYPE.BUFFER,\n};\n\n// We can't set the `src` attribute to empty string, so on abort we set it to this 1px transparent gif\nResource.EMPTY_GIF = 'data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw==';\n\n/**\n * Quick helper to set a value on one of the extension maps. Ensures there is no\n * dot at the start of the extension.\n *\n * @ignore\n * @param {object} map - The map to set on.\n * @param {string} extname - The extension (or key) to set.\n * @param {number} val - The value to set.\n */\nfunction setExtMap(map, extname, val) {\n    if (extname && extname.indexOf('.') === 0) {\n        extname = extname.substring(1);\n    }\n\n    if (!extname) {\n        return;\n    }\n\n    map[extname] = val;\n}\n\n/**\n * Quick helper to get string xhr type.\n *\n * @ignore\n * @param {XMLHttpRequest|XDomainRequest} xhr - The request to check.\n * @return {string} The type.\n */\nfunction reqType(xhr) {\n    return xhr.toString().replace('object ', '');\n}\n\nexport { Resource };\n","const _keyStr = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';\n\n/**\n * Encodes binary into base64.\n *\n * @function encodeBinary\n * @param {string} input The input data to encode.\n * @returns {string} The encoded base64 string\n */\nexport function encodeBinary(input) {\n    let output = '';\n    let inx = 0;\n\n    while (inx < input.length) {\n        // Fill byte buffer array\n        const bytebuffer = [0, 0, 0];\n        const encodedCharIndexes = [0, 0, 0, 0];\n\n        for (let jnx = 0; jnx < bytebuffer.length; ++jnx) {\n            if (inx < input.length) {\n                // throw away high-order byte, as documented at:\n                // https://developer.mozilla.org/En/Using_XMLHttpRequest#Handling_binary_data\n                bytebuffer[jnx] = input.charCodeAt(inx++) & 0xff;\n            }\n            else {\n                bytebuffer[jnx] = 0;\n            }\n        }\n\n        // Get each encoded character, 6 bits at a time\n        // index 1: first 6 bits\n        encodedCharIndexes[0] = bytebuffer[0] >> 2;\n\n        // index 2: second 6 bits (2 least significant bits from input byte 1 + 4 most significant bits from byte 2)\n        encodedCharIndexes[1] = ((bytebuffer[0] & 0x3) << 4) | (bytebuffer[1] >> 4);\n\n        // index 3: third 6 bits (4 least significant bits from input byte 2 + 2 most significant bits from byte 3)\n        encodedCharIndexes[2] = ((bytebuffer[1] & 0x0f) << 2) | (bytebuffer[2] >> 6);\n\n        // index 3: forth 6 bits (6 least significant bits from input byte 3)\n        encodedCharIndexes[3] = bytebuffer[2] & 0x3f;\n\n        // Determine whether padding happened, and adjust accordingly\n        const paddingBytes = inx - (input.length - 1);\n\n        switch (paddingBytes) {\n            case 2:\n                // Set last 2 characters to padding char\n                encodedCharIndexes[3] = 64;\n                encodedCharIndexes[2] = 64;\n                break;\n\n            case 1:\n                // Set last character to padding char\n                encodedCharIndexes[3] = 64;\n                break;\n\n            default:\n                break; // No padding - proceed\n        }\n\n        // Now we will grab each appropriate character out of our keystring\n        // based on our index array and append it to the output string\n        for (let jnx = 0; jnx < encodedCharIndexes.length; ++jnx) {\n            output += _keyStr.charAt(encodedCharIndexes[jnx]);\n        }\n    }\n\n    return output;\n}\n","import { Resource } from '../Resource';\nimport { encodeBinary } from '../encodeBinary';\n\nconst Url = window.URL || window.webkitURL;\n\n/**\n * A middleware for transforming XHR loaded Blobs into more useful objects\n *\n * @memberof middleware\n * @function parsing\n * @example\n * import { Loader, middleware } from 'resource-loader';\n * const loader = new Loader();\n * loader.use(middleware.parsing);\n * @param {Resource} resource - Current Resource\n * @param {function} next - Callback when complete\n */\nexport function parsing(resource, next) {\n    if (!resource.data) {\n        next();\n\n        return;\n    }\n\n    // if this was an XHR load of a blob\n    if (resource.xhr && resource.xhrType === Resource.XHR_RESPONSE_TYPE.BLOB) {\n        // if there is no blob support we probably got a binary string back\n        if (!window.Blob || typeof resource.data === 'string') {\n            const type = resource.xhr.getResponseHeader('content-type');\n\n            // this is an image, convert the binary string into a data url\n            if (type && type.indexOf('image') === 0) {\n                resource.data = new Image();\n                resource.data.src = `data:${type};base64,${encodeBinary(resource.xhr.responseText)}`;\n\n                resource.type = Resource.TYPE.IMAGE;\n\n                // wait until the image loads and then callback\n                resource.data.onload = () => {\n                    resource.data.onload = null;\n\n                    next();\n                };\n\n                // next will be called on load\n                return;\n            }\n        }\n        // if content type says this is an image, then we should transform the blob into an Image object\n        else if (resource.data.type.indexOf('image') === 0) {\n            const src = Url.createObjectURL(resource.data);\n\n            resource.blob = resource.data;\n            resource.data = new Image();\n            resource.data.src = src;\n\n            resource.type = Resource.TYPE.IMAGE;\n\n            // cleanup the no longer used blob after the image loads\n            // TODO: Is this correct? Will the image be invalid after revoking?\n            resource.data.onload = () => {\n                Url.revokeObjectURL(src);\n                resource.data.onload = null;\n\n                next();\n            };\n\n            // next will be called on load.\n            return;\n        }\n    }\n\n    next();\n}\n","/**\n * @namespace middleware\n */\nexport * from './caching';\nexport * from './parsing';\n","import Signal from 'mini-signals';\nimport parseUri from 'parse-uri';\nimport * as async from './async';\nimport { Resource } from './Resource';\n\n// some constants\nconst MAX_PROGRESS = 100;\nconst rgxExtractUrlHash = /(#[\\w-]+)?$/;\n\n/**\n * Manages the state and loading of multiple resources to load.\n *\n * @class\n */\nclass Loader {\n    /**\n     * @param {string} [baseUrl=''] - The base url for all resources loaded by this loader.\n     * @param {number} [concurrency=10] - The number of resources to load concurrently.\n     */\n    constructor(baseUrl = '', concurrency = 10) {\n        /**\n         * The base url for all resources loaded by this loader.\n         *\n         * @member {string}\n         */\n        this.baseUrl = baseUrl;\n\n        /**\n         * The progress percent of the loader going through the queue.\n         *\n         * @member {number}\n         * @default 0\n         */\n        this.progress = 0;\n\n        /**\n         * Loading state of the loader, true if it is currently loading resources.\n         *\n         * @member {boolean}\n         * @default false\n         */\n        this.loading = false;\n\n        /**\n         * A querystring to append to every URL added to the loader.\n         *\n         * This should be a valid query string *without* the question-mark (`?`). The loader will\n         * also *not* escape values for you. Make sure to escape your parameters with\n         * [`encodeURIComponent`](https://mdn.io/encodeURIComponent) before assigning this property.\n         *\n         * @example\n         * const loader = new Loader();\n         *\n         * loader.defaultQueryString = 'user=me&password=secret';\n         *\n         * // This will request 'image.png?user=me&password=secret'\n         * loader.add('image.png').load();\n         *\n         * loader.reset();\n         *\n         * // This will request 'image.png?v=1&user=me&password=secret'\n         * loader.add('iamge.png?v=1').load();\n         *\n         * @member {string}\n         * @default ''\n         */\n        this.defaultQueryString = '';\n\n        /**\n         * The middleware to run before loading each resource.\n         *\n         * @private\n         * @member {function[]}\n         */\n        this._beforeMiddleware = [];\n\n        /**\n         * The middleware to run after loading each resource.\n         *\n         * @private\n         * @member {function[]}\n         */\n        this._afterMiddleware = [];\n\n        /**\n         * The tracks the resources we are currently completing parsing for.\n         *\n         * @private\n         * @member {Resource[]}\n         */\n        this._resourcesParsing = [];\n\n        /**\n         * The `_loadResource` function bound with this object context.\n         *\n         * @private\n         * @member {function}\n         * @param {Resource} r - The resource to load\n         * @param {Function} d - The dequeue function\n         * @return {undefined}\n         */\n        this._boundLoadResource = (r, d) => this._loadResource(r, d);\n\n        /**\n         * The resources waiting to be loaded.\n         *\n         * @private\n         * @member {Resource[]}\n         */\n        this._queue = async.queue(this._boundLoadResource, concurrency);\n\n        this._queue.pause();\n\n        /**\n         * All the resources for this loader keyed by name.\n         *\n         * @member {object<string, Resource>}\n         */\n        this.resources = {};\n\n        /**\n         * Dispatched once per loaded or errored resource.\n         *\n         * The callback looks like {@link Loader.OnProgressSignal}.\n         *\n         * @member {Signal<Loader.OnProgressSignal>}\n         */\n        this.onProgress = new Signal();\n\n        /**\n         * Dispatched once per errored resource.\n         *\n         * The callback looks like {@link Loader.OnErrorSignal}.\n         *\n         * @member {Signal<Loader.OnErrorSignal>}\n         */\n        this.onError = new Signal();\n\n        /**\n         * Dispatched once per loaded resource.\n         *\n         * The callback looks like {@link Loader.OnLoadSignal}.\n         *\n         * @member {Signal<Loader.OnLoadSignal>}\n         */\n        this.onLoad = new Signal();\n\n        /**\n         * Dispatched when the loader begins to process the queue.\n         *\n         * The callback looks like {@link Loader.OnStartSignal}.\n         *\n         * @member {Signal<Loader.OnStartSignal>}\n         */\n        this.onStart = new Signal();\n\n        /**\n         * Dispatched when the queued resources all load.\n         *\n         * The callback looks like {@link Loader.OnCompleteSignal}.\n         *\n         * @member {Signal<Loader.OnCompleteSignal>}\n         */\n        this.onComplete = new Signal();\n\n        // Add default before middleware\n        for (let i = 0; i < Loader._defaultBeforeMiddleware.length; ++i) {\n            this.pre(Loader._defaultBeforeMiddleware[i]);\n        }\n\n        // Add default after middleware\n        for (let i = 0; i < Loader._defaultAfterMiddleware.length; ++i) {\n            this.use(Loader._defaultAfterMiddleware[i]);\n        }\n    }\n\n    /**\n     * When the progress changes the loader and resource are disaptched.\n     *\n     * @memberof Loader\n     * @callback OnProgressSignal\n     * @param {Loader} loader - The loader the progress is advancing on.\n     * @param {Resource} resource - The resource that has completed or failed to cause the progress to advance.\n     */\n\n    /**\n     * When an error occurrs the loader and resource are disaptched.\n     *\n     * @memberof Loader\n     * @callback OnErrorSignal\n     * @param {Loader} loader - The loader the error happened in.\n     * @param {Resource} resource - The resource that caused the error.\n     */\n\n    /**\n     * When a load completes the loader and resource are disaptched.\n     *\n     * @memberof Loader\n     * @callback OnLoadSignal\n     * @param {Loader} loader - The loader that laoded the resource.\n     * @param {Resource} resource - The resource that has completed loading.\n     */\n\n    /**\n     * When the loader starts loading resources it dispatches this callback.\n     *\n     * @memberof Loader\n     * @callback OnStartSignal\n     * @param {Loader} loader - The loader that has started loading resources.\n     */\n\n    /**\n     * When the loader completes loading resources it dispatches this callback.\n     *\n     * @memberof Loader\n     * @callback OnCompleteSignal\n     * @param {Loader} loader - The loader that has finished loading resources.\n     */\n\n    /**\n     * Options for a call to `.add()`.\n     *\n     * @see Loader#add\n     *\n     * @typedef {object} IAddOptions\n     * @property {string} [name] - The name of the resource to load, if not passed the url is used.\n     * @property {string} [key] - Alias for `name`.\n     * @property {string} [url] - The url for this resource, relative to the baseUrl of this loader.\n     * @property {string|boolean} [crossOrigin] - Is this request cross-origin? Default is to\n     *      determine automatically.\n     * @property {number} [timeout=0] - A timeout in milliseconds for the load. If the load takes\n     *      longer than this time it is cancelled and the load is considered a failure. If this value is\n     *      set to `0` then there is no explicit timeout.\n     * @property {Resource.LOAD_TYPE} [loadType=Resource.LOAD_TYPE.XHR] - How should this resource\n     *      be loaded?\n     * @property {Resource.XHR_RESPONSE_TYPE} [xhrType=Resource.XHR_RESPONSE_TYPE.DEFAULT] - How\n     *      should the data being loaded be interpreted when using XHR?\n     * @property {Resource.OnCompleteSignal} [onComplete] - Callback to add an an onComplete signal istener.\n     * @property {Resource.OnCompleteSignal} [callback] - Alias for `onComplete`.\n     * @property {Resource.IMetadata} [metadata] - Extra configuration for middleware and the Resource object.\n     */\n\n    /* eslint-disable require-jsdoc,valid-jsdoc */\n    /**\n     * Adds a resource (or multiple resources) to the loader queue.\n     *\n     * This function can take a wide variety of different parameters. The only thing that is always\n     * required the url to load. All the following will work:\n     *\n     * ```js\n     * loader\n     *     // normal param syntax\n     *     .add('key', 'http://...', function () {})\n     *     .add('http://...', function () {})\n     *     .add('http://...')\n     *\n     *     // object syntax\n     *     .add({\n     *         name: 'key2',\n     *         url: 'http://...'\n     *     }, function () {})\n     *     .add({\n     *         url: 'http://...'\n     *     }, function () {})\n     *     .add({\n     *         name: 'key3',\n     *         url: 'http://...'\n     *         onComplete: function () {}\n     *     })\n     *     .add({\n     *         url: 'https://...',\n     *         onComplete: function () {},\n     *         crossOrigin: true\n     *     })\n     *\n     *     // you can also pass an array of objects or urls or both\n     *     .add([\n     *         { name: 'key4', url: 'http://...', onComplete: function () {} },\n     *         { url: 'http://...', onComplete: function () {} },\n     *         'http://...'\n     *     ])\n     *\n     *     // and you can use both params and options\n     *     .add('key', 'http://...', { crossOrigin: true }, function () {})\n     *     .add('http://...', { crossOrigin: true }, function () {});\n     * ```\n     *\n     * @function\n     * @variation 1\n     * @param {string} name - The name of the resource to load.\n     * @param {string} url - The url for this resource, relative to the baseUrl of this loader.\n     * @param {Resource.OnCompleteSignal} [callback] - Function to call when this specific resource completes loading.\n     * @return {this} Returns itself.\n     *//**\n     * @function\n     * @variation 2\n     * @param {string} name - The name of the resource to load.\n     * @param {string} url - The url for this resource, relative to the baseUrl of this loader.\n     * @param {IAddOptions} [options] - The options for the load.\n     * @param {Resource.OnCompleteSignal} [callback] - Function to call when this specific resource completes loading.\n     * @return {this} Returns itself.\n     *//**\n     * @function\n     * @variation 3\n     * @param {string} url - The url for this resource, relative to the baseUrl of this loader.\n     * @param {Resource.OnCompleteSignal} [callback] - Function to call when this specific resource completes loading.\n     * @return {this} Returns itself.\n     *//**\n     * @function\n     * @variation 4\n     * @param {string} url - The url for this resource, relative to the baseUrl of this loader.\n     * @param {IAddOptions} [options] - The options for the load.\n     * @param {Resource.OnCompleteSignal} [callback] - Function to call when this specific resource completes loading.\n     * @return {this} Returns itself.\n     *//**\n     * @function\n     * @variation 5\n     * @param {IAddOptions} options - The options for the load. This object must contain a `url` property.\n     * @param {Resource.OnCompleteSignal} [callback] - Function to call when this specific resource completes loading.\n     * @return {this} Returns itself.\n     *//**\n     * @function\n     * @variation 6\n     * @param {Array<IAddOptions|string>} resources - An array of resources to load, where each is\n     *      either an object with the options or a string url. If you pass an object, it must contain a `url` property.\n     * @param {Resource.OnCompleteSignal} [callback] - Function to call when this specific resource completes loading.\n     * @return {this} Returns itself.\n     */\n    add(name, url, options, cb) {\n        // special case of an array of objects or urls\n        if (Array.isArray(name)) {\n            for (let i = 0; i < name.length; ++i) {\n                this.add(name[i]);\n            }\n\n            return this;\n        }\n\n        // if an object is passed instead of params\n        if (typeof name === 'object') {\n            cb = url || name.callback || name.onComplete;\n            options = name;\n            url = name.url;\n            name = name.name || name.key || name.url;\n        }\n\n        // case where no name is passed shift all args over by one.\n        if (typeof url !== 'string') {\n            cb = options;\n            options = url;\n            url = name;\n        }\n\n        // now that we shifted make sure we have a proper url.\n        if (typeof url !== 'string') {\n            throw new Error('No url passed to add resource to loader.');\n        }\n\n        // options are optional so people might pass a function and no options\n        if (typeof options === 'function') {\n            cb = options;\n            options = null;\n        }\n\n        // if loading already you can only add resources that have a parent.\n        if (this.loading && (!options || !options.parentResource)) {\n            throw new Error('Cannot add resources while the loader is running.');\n        }\n\n        // check if resource already exists.\n        if (this.resources[name]) {\n            throw new Error(`Resource named \"${name}\" already exists.`);\n        }\n\n        // add base url if this isn't an absolute url\n        url = this._prepareUrl(url);\n\n        // create the store the resource\n        this.resources[name] = new Resource(name, url, options);\n\n        if (typeof cb === 'function') {\n            this.resources[name].onAfterMiddleware.once(cb);\n        }\n\n        // if actively loading, make sure to adjust progress chunks for that parent and its children\n        if (this.loading) {\n            const parent = options.parentResource;\n            const incompleteChildren = [];\n\n            for (let i = 0; i < parent.children.length; ++i) {\n                if (!parent.children[i].isComplete) {\n                    incompleteChildren.push(parent.children[i]);\n                }\n            }\n\n            const fullChunk = parent.progressChunk * (incompleteChildren.length + 1); // +1 for parent\n            const eachChunk = fullChunk / (incompleteChildren.length + 2); // +2 for parent & new child\n\n            parent.children.push(this.resources[name]);\n            parent.progressChunk = eachChunk;\n\n            for (let i = 0; i < incompleteChildren.length; ++i) {\n                incompleteChildren[i].progressChunk = eachChunk;\n            }\n\n            this.resources[name].progressChunk = eachChunk;\n        }\n\n        // add the resource to the queue\n        this._queue.push(this.resources[name]);\n\n        return this;\n    }\n    /* eslint-enable require-jsdoc,valid-jsdoc */\n\n    /**\n     * Sets up a middleware function that will run *before* the\n     * resource is loaded.\n     *\n     * @param {function} fn - The middleware function to register.\n     * @return {this} Returns itself.\n     */\n    pre(fn) {\n        this._beforeMiddleware.push(fn);\n\n        return this;\n    }\n\n    /**\n     * Sets up a middleware function that will run *after* the\n     * resource is loaded.\n     *\n     * @param {function} fn - The middleware function to register.\n     * @return {this} Returns itself.\n     */\n    use(fn) {\n        this._afterMiddleware.push(fn);\n\n        return this;\n    }\n\n    /**\n     * Resets the queue of the loader to prepare for a new load.\n     *\n     * @return {this} Returns itself.\n     */\n    reset() {\n        this.progress = 0;\n        this.loading = false;\n\n        this._queue.kill();\n        this._queue.pause();\n\n        // abort all resource loads\n        for (const k in this.resources) {\n            const res = this.resources[k];\n\n            if (res._onLoadBinding) {\n                res._onLoadBinding.detach();\n            }\n\n            if (res.isLoading) {\n                res.abort();\n            }\n        }\n\n        this.resources = {};\n\n        return this;\n    }\n\n    /**\n     * Starts loading the queued resources.\n     *\n     * @param {function} [cb] - Optional callback that will be bound to the `complete` event.\n     * @return {this} Returns itself.\n     */\n    load(cb) {\n        // register complete callback if they pass one\n        if (typeof cb === 'function') {\n            this.onComplete.once(cb);\n        }\n\n        // if the queue has already started we are done here\n        if (this.loading) {\n            return this;\n        }\n\n        if (this._queue.idle()) {\n            this._onStart();\n            this._onComplete();\n        }\n        else {\n            // distribute progress chunks\n            const numTasks = this._queue._tasks.length;\n            const chunk = MAX_PROGRESS / numTasks;\n\n            for (let i = 0; i < this._queue._tasks.length; ++i) {\n                this._queue._tasks[i].data.progressChunk = chunk;\n            }\n\n            // notify we are starting\n            this._onStart();\n\n            // start loading\n            this._queue.resume();\n        }\n\n        return this;\n    }\n\n    /**\n     * The number of resources to load concurrently.\n     *\n     * @member {number}\n     * @default 10\n     */\n    get concurrency() {\n        return this._queue.concurrency;\n    }\n    // eslint-disable-next-line require-jsdoc\n    set concurrency(concurrency) {\n        this._queue.concurrency = concurrency;\n    }\n\n    /**\n     * Prepares a url for usage based on the configuration of this object\n     *\n     * @private\n     * @param {string} url - The url to prepare.\n     * @return {string} The prepared url.\n     */\n    _prepareUrl(url) {\n        const parsedUrl = parseUri(url, { strictMode: true });\n        let result;\n\n        // absolute url, just use it as is.\n        if (parsedUrl.protocol || !parsedUrl.path || url.indexOf('//') === 0) {\n            result = url;\n        }\n        // if baseUrl doesn't end in slash and url doesn't start with slash, then add a slash inbetween\n        else if (this.baseUrl.length\n            && this.baseUrl.lastIndexOf('/') !== this.baseUrl.length - 1\n            && url.charAt(0) !== '/'\n        ) {\n            result = `${this.baseUrl}/${url}`;\n        }\n        else {\n            result = this.baseUrl + url;\n        }\n\n        // if we need to add a default querystring, there is a bit more work\n        if (this.defaultQueryString) {\n            const hash = rgxExtractUrlHash.exec(result)[0];\n\n            result = result.substr(0, result.length - hash.length);\n\n            if (result.indexOf('?') !== -1) {\n                result += `&${this.defaultQueryString}`;\n            }\n            else {\n                result += `?${this.defaultQueryString}`;\n            }\n\n            result += hash;\n        }\n\n        return result;\n    }\n\n    /**\n     * Loads a single resource.\n     *\n     * @private\n     * @param {Resource} resource - The resource to load.\n     * @param {function} dequeue - The function to call when we need to dequeue this item.\n     */\n    _loadResource(resource, dequeue) {\n        resource._dequeue = dequeue;\n\n        // run before middleware\n        async.eachSeries(\n            this._beforeMiddleware,\n            (fn, next) => {\n                fn.call(this, resource, () => {\n                    // if the before middleware marks the resource as complete,\n                    // break and don't process any more before middleware\n                    next(resource.isComplete ? {} : null);\n                });\n            },\n            () => {\n                if (resource.isComplete) {\n                    this._onLoad(resource);\n                }\n                else {\n                    resource._onLoadBinding = resource.onComplete.once(this._onLoad, this);\n                    resource.load();\n                }\n            },\n            true\n        );\n    }\n\n    /**\n     * Called once loading has started.\n     *\n     * @private\n     */\n    _onStart() {\n        this.progress = 0;\n        this.loading = true;\n        this.onStart.dispatch(this);\n    }\n\n    /**\n     * Called once each resource has loaded.\n     *\n     * @private\n     */\n    _onComplete() {\n        this.progress = MAX_PROGRESS;\n        this.loading = false;\n        this.onComplete.dispatch(this, this.resources);\n    }\n\n    /**\n     * Called each time a resources is loaded.\n     *\n     * @private\n     * @param {Resource} resource - The resource that was loaded\n     */\n    _onLoad(resource) {\n        resource._onLoadBinding = null;\n\n        // remove this resource from the async queue, and add it to our list of resources that are being parsed\n        this._resourcesParsing.push(resource);\n        resource._dequeue();\n\n        // run all the after middleware for this resource\n        async.eachSeries(\n            this._afterMiddleware,\n            (fn, next) => {\n                fn.call(this, resource, next);\n            },\n            () => {\n                resource.onAfterMiddleware.dispatch(resource);\n\n                this.progress = Math.min(MAX_PROGRESS, this.progress + resource.progressChunk);\n                this.onProgress.dispatch(this, resource);\n\n                if (resource.error) {\n                    this.onError.dispatch(resource.error, this, resource);\n                }\n                else {\n                    this.onLoad.dispatch(this, resource);\n                }\n\n                this._resourcesParsing.splice(this._resourcesParsing.indexOf(resource), 1);\n\n                // do completion check\n                if (this._queue.idle() && this._resourcesParsing.length === 0) {\n                    this._onComplete();\n                }\n            },\n            true\n        );\n    }\n}\n\n/**\n * A default array of middleware to run before loading each resource.\n * Each of these middlewares are added to any new Loader instances when they are created.\n *\n * @private\n * @member {function[]}\n */\nLoader._defaultBeforeMiddleware = [];\n\n/**\n * A default array of middleware to run after loading each resource.\n * Each of these middlewares are added to any new Loader instances when they are created.\n *\n * @private\n * @member {function[]}\n */\nLoader._defaultAfterMiddleware = [];\n\n/**\n * Sets up a middleware function that will run *before* the\n * resource is loaded.\n *\n * @static\n * @param {function} fn - The middleware function to register.\n * @return {Loader} Returns itself.\n */\nLoader.pre = function LoaderPreStatic(fn) {\n    Loader._defaultBeforeMiddleware.push(fn);\n\n    return Loader;\n};\n\n/**\n * Sets up a middleware function that will run *after* the\n * resource is loaded.\n *\n * @static\n * @param {function} fn - The middleware function to register.\n * @return {Loader} Returns itself.\n */\nLoader.use = function LoaderUseStatic(fn) {\n    Loader._defaultAfterMiddleware.push(fn);\n\n    return Loader;\n};\n\nexport { Loader };\n\n"]},"metadata":{},"sourceType":"module"}