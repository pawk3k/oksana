{"ast":null,"code":"/*!\n * @pixi/display - v5.2.1\n * Compiled Tue, 28 Jan 2020 23:33:11 UTC\n *\n * @pixi/display is licensed under the MIT License.\n * http://www.opensource.org/licenses/mit-license\n */\nimport { settings } from '@pixi/settings';\nimport { Rectangle, RAD_TO_DEG, DEG_TO_RAD, Transform } from '@pixi/math';\nimport { EventEmitter, removeItems } from '@pixi/utils';\n/**\n * Sets the default value for the container property 'sortableChildren'.\n * If set to true, the container will sort its children by zIndex value\n * when updateTransform() is called, or manually if sortChildren() is called.\n *\n * This actually changes the order of elements in the array, so should be treated\n * as a basic solution that is not performant compared to other solutions,\n * such as @link https://github.com/pixijs/pixi-display\n *\n * Also be aware of that this may not work nicely with the addChildAt() function,\n * as the zIndex sorting may cause the child to automatically sorted to another position.\n *\n * @static\n * @constant\n * @name SORTABLE_CHILDREN\n * @memberof PIXI.settings\n * @type {boolean}\n * @default false\n */\n\nsettings.SORTABLE_CHILDREN = false;\n/**\n * 'Builder' pattern for bounds rectangles.\n *\n * This could be called an Axis-Aligned Bounding Box.\n * It is not an actual shape. It is a mutable thing; no 'EMPTY' or those kind of problems.\n *\n * @class\n * @memberof PIXI\n */\n\nvar Bounds = function Bounds() {\n  /**\n   * @member {number}\n   * @default 0\n   */\n  this.minX = Infinity;\n  /**\n   * @member {number}\n   * @default 0\n   */\n\n  this.minY = Infinity;\n  /**\n   * @member {number}\n   * @default 0\n   */\n\n  this.maxX = -Infinity;\n  /**\n   * @member {number}\n   * @default 0\n   */\n\n  this.maxY = -Infinity;\n  this.rect = null;\n};\n/**\n * Checks if bounds are empty.\n *\n * @return {boolean} True if empty.\n */\n\n\nBounds.prototype.isEmpty = function isEmpty() {\n  return this.minX > this.maxX || this.minY > this.maxY;\n};\n/**\n * Clears the bounds and resets.\n *\n */\n\n\nBounds.prototype.clear = function clear() {\n  this.minX = Infinity;\n  this.minY = Infinity;\n  this.maxX = -Infinity;\n  this.maxY = -Infinity;\n};\n/**\n * Can return Rectangle.EMPTY constant, either construct new rectangle, either use your rectangle\n * It is not guaranteed that it will return tempRect\n *\n * @param {PIXI.Rectangle} rect - temporary object will be used if AABB is not empty\n * @returns {PIXI.Rectangle} A rectangle of the bounds\n */\n\n\nBounds.prototype.getRectangle = function getRectangle(rect) {\n  if (this.minX > this.maxX || this.minY > this.maxY) {\n    return Rectangle.EMPTY;\n  }\n\n  rect = rect || new Rectangle(0, 0, 1, 1);\n  rect.x = this.minX;\n  rect.y = this.minY;\n  rect.width = this.maxX - this.minX;\n  rect.height = this.maxY - this.minY;\n  return rect;\n};\n/**\n * This function should be inlined when its possible.\n *\n * @param {PIXI.Point} point - The point to add.\n */\n\n\nBounds.prototype.addPoint = function addPoint(point) {\n  this.minX = Math.min(this.minX, point.x);\n  this.maxX = Math.max(this.maxX, point.x);\n  this.minY = Math.min(this.minY, point.y);\n  this.maxY = Math.max(this.maxY, point.y);\n};\n/**\n * Adds a quad, not transformed\n *\n * @param {Float32Array} vertices - The verts to add.\n */\n\n\nBounds.prototype.addQuad = function addQuad(vertices) {\n  var minX = this.minX;\n  var minY = this.minY;\n  var maxX = this.maxX;\n  var maxY = this.maxY;\n  var x = vertices[0];\n  var y = vertices[1];\n  minX = x < minX ? x : minX;\n  minY = y < minY ? y : minY;\n  maxX = x > maxX ? x : maxX;\n  maxY = y > maxY ? y : maxY;\n  x = vertices[2];\n  y = vertices[3];\n  minX = x < minX ? x : minX;\n  minY = y < minY ? y : minY;\n  maxX = x > maxX ? x : maxX;\n  maxY = y > maxY ? y : maxY;\n  x = vertices[4];\n  y = vertices[5];\n  minX = x < minX ? x : minX;\n  minY = y < minY ? y : minY;\n  maxX = x > maxX ? x : maxX;\n  maxY = y > maxY ? y : maxY;\n  x = vertices[6];\n  y = vertices[7];\n  minX = x < minX ? x : minX;\n  minY = y < minY ? y : minY;\n  maxX = x > maxX ? x : maxX;\n  maxY = y > maxY ? y : maxY;\n  this.minX = minX;\n  this.minY = minY;\n  this.maxX = maxX;\n  this.maxY = maxY;\n};\n/**\n * Adds sprite frame, transformed.\n *\n * @param {PIXI.Transform} transform - transform to apply\n * @param {number} x0 - left X of frame\n * @param {number} y0 - top Y of frame\n * @param {number} x1 - right X of frame\n * @param {number} y1 - bottom Y of frame\n */\n\n\nBounds.prototype.addFrame = function addFrame(transform, x0, y0, x1, y1) {\n  this.addFrameMatrix(transform.worldTransform, x0, y0, x1, y1);\n};\n/**\n * Adds sprite frame, multiplied by matrix\n *\n * @param {PIXI.Matrix} matrix - matrix to apply\n * @param {number} x0 - left X of frame\n * @param {number} y0 - top Y of frame\n * @param {number} x1 - right X of frame\n * @param {number} y1 - bottom Y of frame\n */\n\n\nBounds.prototype.addFrameMatrix = function addFrameMatrix(matrix, x0, y0, x1, y1) {\n  var a = matrix.a;\n  var b = matrix.b;\n  var c = matrix.c;\n  var d = matrix.d;\n  var tx = matrix.tx;\n  var ty = matrix.ty;\n  var minX = this.minX;\n  var minY = this.minY;\n  var maxX = this.maxX;\n  var maxY = this.maxY;\n  var x = a * x0 + c * y0 + tx;\n  var y = b * x0 + d * y0 + ty;\n  minX = x < minX ? x : minX;\n  minY = y < minY ? y : minY;\n  maxX = x > maxX ? x : maxX;\n  maxY = y > maxY ? y : maxY;\n  x = a * x1 + c * y0 + tx;\n  y = b * x1 + d * y0 + ty;\n  minX = x < minX ? x : minX;\n  minY = y < minY ? y : minY;\n  maxX = x > maxX ? x : maxX;\n  maxY = y > maxY ? y : maxY;\n  x = a * x0 + c * y1 + tx;\n  y = b * x0 + d * y1 + ty;\n  minX = x < minX ? x : minX;\n  minY = y < minY ? y : minY;\n  maxX = x > maxX ? x : maxX;\n  maxY = y > maxY ? y : maxY;\n  x = a * x1 + c * y1 + tx;\n  y = b * x1 + d * y1 + ty;\n  minX = x < minX ? x : minX;\n  minY = y < minY ? y : minY;\n  maxX = x > maxX ? x : maxX;\n  maxY = y > maxY ? y : maxY;\n  this.minX = minX;\n  this.minY = minY;\n  this.maxX = maxX;\n  this.maxY = maxY;\n};\n/**\n * Adds screen vertices from array\n *\n * @param {Float32Array} vertexData - calculated vertices\n * @param {number} beginOffset - begin offset\n * @param {number} endOffset - end offset, excluded\n */\n\n\nBounds.prototype.addVertexData = function addVertexData(vertexData, beginOffset, endOffset) {\n  var minX = this.minX;\n  var minY = this.minY;\n  var maxX = this.maxX;\n  var maxY = this.maxY;\n\n  for (var i = beginOffset; i < endOffset; i += 2) {\n    var x = vertexData[i];\n    var y = vertexData[i + 1];\n    minX = x < minX ? x : minX;\n    minY = y < minY ? y : minY;\n    maxX = x > maxX ? x : maxX;\n    maxY = y > maxY ? y : maxY;\n  }\n\n  this.minX = minX;\n  this.minY = minY;\n  this.maxX = maxX;\n  this.maxY = maxY;\n};\n/**\n * Add an array of mesh vertices\n *\n * @param {PIXI.Transform} transform - mesh transform\n * @param {Float32Array} vertices - mesh coordinates in array\n * @param {number} beginOffset - begin offset\n * @param {number} endOffset - end offset, excluded\n */\n\n\nBounds.prototype.addVertices = function addVertices(transform, vertices, beginOffset, endOffset) {\n  this.addVerticesMatrix(transform.worldTransform, vertices, beginOffset, endOffset);\n};\n/**\n * Add an array of mesh vertices\n *\n * @param {PIXI.Matrix} matrix - mesh matrix\n * @param {Float32Array} vertices - mesh coordinates in array\n * @param {number} beginOffset - begin offset\n * @param {number} endOffset - end offset, excluded\n * @param {number} [padX] - x padding\n * @param {number} [padY] - y padding\n */\n\n\nBounds.prototype.addVerticesMatrix = function addVerticesMatrix(matrix, vertices, beginOffset, endOffset, padX, padY) {\n  var a = matrix.a;\n  var b = matrix.b;\n  var c = matrix.c;\n  var d = matrix.d;\n  var tx = matrix.tx;\n  var ty = matrix.ty;\n  padX = padX || 0;\n  padY = padY || 0;\n  var minX = this.minX;\n  var minY = this.minY;\n  var maxX = this.maxX;\n  var maxY = this.maxY;\n\n  for (var i = beginOffset; i < endOffset; i += 2) {\n    var rawX = vertices[i];\n    var rawY = vertices[i + 1];\n    var x = a * rawX + c * rawY + tx;\n    var y = d * rawY + b * rawX + ty;\n    minX = Math.min(minX, x - padX);\n    maxX = Math.max(maxX, x + padX);\n    minY = Math.min(minY, y - padY);\n    maxY = Math.max(maxY, y + padY);\n  }\n\n  this.minX = minX;\n  this.minY = minY;\n  this.maxX = maxX;\n  this.maxY = maxY;\n};\n/**\n * Adds other Bounds\n *\n * @param {PIXI.Bounds} bounds - TODO\n */\n\n\nBounds.prototype.addBounds = function addBounds(bounds) {\n  var minX = this.minX;\n  var minY = this.minY;\n  var maxX = this.maxX;\n  var maxY = this.maxY;\n  this.minX = bounds.minX < minX ? bounds.minX : minX;\n  this.minY = bounds.minY < minY ? bounds.minY : minY;\n  this.maxX = bounds.maxX > maxX ? bounds.maxX : maxX;\n  this.maxY = bounds.maxY > maxY ? bounds.maxY : maxY;\n};\n/**\n * Adds other Bounds, masked with Bounds\n *\n * @param {PIXI.Bounds} bounds - TODO\n * @param {PIXI.Bounds} mask - TODO\n */\n\n\nBounds.prototype.addBoundsMask = function addBoundsMask(bounds, mask) {\n  var _minX = bounds.minX > mask.minX ? bounds.minX : mask.minX;\n\n  var _minY = bounds.minY > mask.minY ? bounds.minY : mask.minY;\n\n  var _maxX = bounds.maxX < mask.maxX ? bounds.maxX : mask.maxX;\n\n  var _maxY = bounds.maxY < mask.maxY ? bounds.maxY : mask.maxY;\n\n  if (_minX <= _maxX && _minY <= _maxY) {\n    var minX = this.minX;\n    var minY = this.minY;\n    var maxX = this.maxX;\n    var maxY = this.maxY;\n    this.minX = _minX < minX ? _minX : minX;\n    this.minY = _minY < minY ? _minY : minY;\n    this.maxX = _maxX > maxX ? _maxX : maxX;\n    this.maxY = _maxY > maxY ? _maxY : maxY;\n  }\n};\n/**\n * Adds other Bounds, multiplied by matrix. Bounds shouldn't be empty\n *\n * @param {PIXI.Bounds} bounds other bounds\n * @param {PIXI.Matrix} matrix multiplicator\n */\n\n\nBounds.prototype.addBoundsMatrix = function addBoundsMatrix(bounds, matrix) {\n  this.addFrameMatrix(matrix, bounds.minX, bounds.minY, bounds.maxX, bounds.maxY);\n};\n/**\n * Adds other Bounds, masked with Rectangle\n *\n * @param {PIXI.Bounds} bounds - TODO\n * @param {PIXI.Rectangle} area - TODO\n */\n\n\nBounds.prototype.addBoundsArea = function addBoundsArea(bounds, area) {\n  var _minX = bounds.minX > area.x ? bounds.minX : area.x;\n\n  var _minY = bounds.minY > area.y ? bounds.minY : area.y;\n\n  var _maxX = bounds.maxX < area.x + area.width ? bounds.maxX : area.x + area.width;\n\n  var _maxY = bounds.maxY < area.y + area.height ? bounds.maxY : area.y + area.height;\n\n  if (_minX <= _maxX && _minY <= _maxY) {\n    var minX = this.minX;\n    var minY = this.minY;\n    var maxX = this.maxX;\n    var maxY = this.maxY;\n    this.minX = _minX < minX ? _minX : minX;\n    this.minY = _minY < minY ? _minY : minY;\n    this.maxX = _maxX > maxX ? _maxX : maxX;\n    this.maxY = _maxY > maxY ? _maxY : maxY;\n  }\n};\n/**\n * Pads bounds object, making it grow in all directions.\n * If paddingY is omitted, both paddingX and paddingY will be set to paddingX.\n *\n * @param {number} [paddingX=0] - The horizontal padding amount.\n * @param {number} [paddingY=0] - The vertical padding amount.\n */\n\n\nBounds.prototype.pad = function pad(paddingX, paddingY) {\n  paddingX = paddingX || 0;\n  paddingY = paddingY || (paddingY !== 0 ? paddingX : 0);\n\n  if (!this.isEmpty()) {\n    this.minX -= paddingX;\n    this.maxX += paddingX;\n    this.minY -= paddingY;\n    this.maxY += paddingY;\n  }\n};\n/**\n * Adds padded frame. (x0, y0) should be strictly less than (x1, y1)\n *\n * @param {number} x0 - left X of frame\n * @param {number} y0 - top Y of frame\n * @param {number} x1 - right X of frame\n * @param {number} y1 - bottom Y of frame\n * @param {number} padX - padding X\n * @param {number} padY - padding Y\n */\n\n\nBounds.prototype.addFramePad = function addFramePad(x0, y0, x1, y1, padX, padY) {\n  x0 -= padX;\n  y0 -= padY;\n  x1 += padX;\n  y1 += padY;\n  this.minX = this.minX < x0 ? this.minX : x0;\n  this.maxX = this.maxX > x1 ? this.maxX : x1;\n  this.minY = this.minY < y0 ? this.minY : y0;\n  this.maxY = this.maxY > y1 ? this.maxY : y1;\n}; // _tempDisplayObjectParent = new DisplayObject();\n\n/**\n * The base class for all objects that are rendered on the screen.\n *\n * This is an abstract class and should not be used on its own; rather it should be extended.\n *\n * @class\n * @extends PIXI.utils.EventEmitter\n * @memberof PIXI\n */\n\n\nvar DisplayObject =\n/*@__PURE__*/\nfunction (EventEmitter) {\n  function DisplayObject() {\n    EventEmitter.call(this);\n    this.tempDisplayObjectParent = null; // TODO: need to create Transform from factory\n\n    /**\n     * World transform and local transform of this object.\n     * This will become read-only later, please do not assign anything there unless you know what are you doing.\n     *\n     * @member {PIXI.Transform}\n     */\n\n    this.transform = new Transform();\n    /**\n     * The opacity of the object.\n     *\n     * @member {number}\n     */\n\n    this.alpha = 1;\n    /**\n     * The visibility of the object. If false the object will not be drawn, and\n     * the updateTransform function will not be called.\n     *\n     * Only affects recursive calls from parent. You can ask for bounds or call updateTransform manually.\n     *\n     * @member {boolean}\n     */\n\n    this.visible = true;\n    /**\n     * Can this object be rendered, if false the object will not be drawn but the updateTransform\n     * methods will still be called.\n     *\n     * Only affects recursive calls from parent. You can ask for bounds manually.\n     *\n     * @member {boolean}\n     */\n\n    this.renderable = true;\n    /**\n     * The display object container that contains this display object.\n     *\n     * @member {PIXI.Container}\n     * @readonly\n     */\n\n    this.parent = null;\n    /**\n     * The multiplied alpha of the displayObject.\n     *\n     * @member {number}\n     * @readonly\n     */\n\n    this.worldAlpha = 1;\n    /**\n     * Which index in the children array the display component was before the previous zIndex sort.\n     * Used by containers to help sort objects with the same zIndex, by using previous array index as the decider.\n     *\n     * @member {number}\n     * @protected\n     */\n\n    this._lastSortedIndex = 0;\n    /**\n     * The zIndex of the displayObject.\n     * A higher value will mean it will be rendered on top of other displayObjects within the same container.\n     *\n     * @member {number}\n     * @protected\n     */\n\n    this._zIndex = 0;\n    /**\n     * The area the filter is applied to. This is used as more of an optimization\n     * rather than figuring out the dimensions of the displayObject each frame you can set this rectangle.\n     *\n     * Also works as an interaction mask.\n     *\n     * @member {?PIXI.Rectangle}\n     */\n\n    this.filterArea = null;\n    /**\n     * Sets the filters for the displayObject.\n     * * IMPORTANT: This is a WebGL only feature and will be ignored by the canvas renderer.\n     * To remove filters simply set this property to `'null'`.\n     *\n     * @member {?PIXI.Filter[]}\n     */\n\n    this.filters = null;\n    this._enabledFilters = null;\n    /**\n     * The bounds object, this is used to calculate and store the bounds of the displayObject.\n     *\n     * @member {PIXI.Bounds}\n     * @protected\n     */\n\n    this._bounds = new Bounds();\n    this._boundsID = 0;\n    this._lastBoundsID = -1;\n    this._boundsRect = null;\n    this._localBoundsRect = null;\n    /**\n     * The original, cached mask of the object.\n     *\n     * @member {PIXI.Graphics|PIXI.Sprite|null}\n     * @protected\n     */\n\n    this._mask = null;\n    /**\n     * Fired when this DisplayObject is added to a Container.\n     *\n     * @event PIXI.DisplayObject#added\n     * @param {PIXI.Container} container - The container added to.\n     */\n\n    /**\n     * Fired when this DisplayObject is removed from a Container.\n     *\n     * @event PIXI.DisplayObject#removed\n     * @param {PIXI.Container} container - The container removed from.\n     */\n\n    /**\n     * If the object has been destroyed via destroy(). If true, it should not be used.\n     *\n     * @member {boolean}\n     * @protected\n     */\n\n    this._destroyed = false;\n    /**\n     * used to fast check if a sprite is.. a sprite!\n     * @member {boolean}\n     */\n\n    this.isSprite = false;\n    /**\n     * Does any other displayObject use this object as a mask?\n     * @member {boolean}\n     */\n\n    this.isMask = false;\n  }\n\n  if (EventEmitter) DisplayObject.__proto__ = EventEmitter;\n  DisplayObject.prototype = Object.create(EventEmitter && EventEmitter.prototype);\n  DisplayObject.prototype.constructor = DisplayObject;\n  var prototypeAccessors = {\n    _tempDisplayObjectParent: {\n      configurable: true\n    },\n    x: {\n      configurable: true\n    },\n    y: {\n      configurable: true\n    },\n    worldTransform: {\n      configurable: true\n    },\n    localTransform: {\n      configurable: true\n    },\n    position: {\n      configurable: true\n    },\n    scale: {\n      configurable: true\n    },\n    pivot: {\n      configurable: true\n    },\n    skew: {\n      configurable: true\n    },\n    rotation: {\n      configurable: true\n    },\n    angle: {\n      configurable: true\n    },\n    zIndex: {\n      configurable: true\n    },\n    worldVisible: {\n      configurable: true\n    },\n    mask: {\n      configurable: true\n    }\n  };\n  /**\n   * @protected\n   * @member {PIXI.DisplayObject}\n   */\n\n  DisplayObject.mixin = function mixin(source) {\n    // in ES8/ES2017, this would be really easy:\n    // Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    // get all the enumerable property keys\n    var keys = Object.keys(source); // loop through properties\n\n    for (var i = 0; i < keys.length; ++i) {\n      var propertyName = keys[i]; // Set the property using the property descriptor - this works for accessors and normal value properties\n\n      Object.defineProperty(DisplayObject.prototype, propertyName, Object.getOwnPropertyDescriptor(source, propertyName));\n    }\n  };\n\n  prototypeAccessors._tempDisplayObjectParent.get = function () {\n    if (this.tempDisplayObjectParent === null) {\n      this.tempDisplayObjectParent = new DisplayObject();\n    }\n\n    return this.tempDisplayObjectParent;\n  };\n  /**\n   * Updates the object transform for rendering.\n   *\n   * TODO - Optimization pass!\n   */\n\n\n  DisplayObject.prototype.updateTransform = function updateTransform() {\n    this._boundsID++;\n    this.transform.updateTransform(this.parent.transform); // multiply the alphas..\n\n    this.worldAlpha = this.alpha * this.parent.worldAlpha;\n  };\n  /**\n   * Recalculates the bounds of the display object.\n   *\n   * Does nothing by default and can be overwritten in a parent class.\n   */\n\n\n  DisplayObject.prototype.calculateBounds = function calculateBounds() {// OVERWRITE;\n  };\n  /**\n   * Recursively updates transform of all objects from the root to this one\n   * internal function for toLocal()\n   */\n\n\n  DisplayObject.prototype._recursivePostUpdateTransform = function _recursivePostUpdateTransform() {\n    if (this.parent) {\n      this.parent._recursivePostUpdateTransform();\n\n      this.transform.updateTransform(this.parent.transform);\n    } else {\n      this.transform.updateTransform(this._tempDisplayObjectParent.transform);\n    }\n  };\n  /**\n   * Retrieves the bounds of the displayObject as a rectangle object.\n   *\n   * @param {boolean} [skipUpdate] - Setting to `true` will stop the transforms of the scene graph from\n   *  being updated. This means the calculation returned MAY be out of date BUT will give you a\n   *  nice performance boost.\n   * @param {PIXI.Rectangle} [rect] - Optional rectangle to store the result of the bounds calculation.\n   * @return {PIXI.Rectangle} The rectangular bounding area.\n   */\n\n\n  DisplayObject.prototype.getBounds = function getBounds(skipUpdate, rect) {\n    if (!skipUpdate) {\n      if (!this.parent) {\n        this.parent = this._tempDisplayObjectParent;\n        this.updateTransform();\n        this.parent = null;\n      } else {\n        this._recursivePostUpdateTransform();\n\n        this.updateTransform();\n      }\n    }\n\n    if (this._boundsID !== this._lastBoundsID) {\n      this.calculateBounds();\n      this._lastBoundsID = this._boundsID;\n    }\n\n    if (!rect) {\n      if (!this._boundsRect) {\n        this._boundsRect = new Rectangle();\n      }\n\n      rect = this._boundsRect;\n    }\n\n    return this._bounds.getRectangle(rect);\n  };\n  /**\n   * Retrieves the local bounds of the displayObject as a rectangle object.\n   *\n   * @param {PIXI.Rectangle} [rect] - Optional rectangle to store the result of the bounds calculation.\n   * @return {PIXI.Rectangle} The rectangular bounding area.\n   */\n\n\n  DisplayObject.prototype.getLocalBounds = function getLocalBounds(rect) {\n    var transformRef = this.transform;\n    var parentRef = this.parent;\n    this.parent = null;\n    this.transform = this._tempDisplayObjectParent.transform;\n\n    if (!rect) {\n      if (!this._localBoundsRect) {\n        this._localBoundsRect = new Rectangle();\n      }\n\n      rect = this._localBoundsRect;\n    }\n\n    var bounds = this.getBounds(false, rect);\n    this.parent = parentRef;\n    this.transform = transformRef;\n    return bounds;\n  };\n  /**\n   * Calculates the global position of the display object.\n   *\n   * @param {PIXI.IPoint} position - The world origin to calculate from.\n   * @param {PIXI.IPoint} [point] - A Point object in which to store the value, optional\n   *  (otherwise will create a new Point).\n   * @param {boolean} [skipUpdate=false] - Should we skip the update transform.\n   * @return {PIXI.IPoint} A point object representing the position of this object.\n   */\n\n\n  DisplayObject.prototype.toGlobal = function toGlobal(position, point, skipUpdate) {\n    if (skipUpdate === void 0) skipUpdate = false;\n\n    if (!skipUpdate) {\n      this._recursivePostUpdateTransform(); // this parent check is for just in case the item is a root object.\n      // If it is we need to give it a temporary parent so that displayObjectUpdateTransform works correctly\n      // this is mainly to avoid a parent check in the main loop. Every little helps for performance :)\n\n\n      if (!this.parent) {\n        this.parent = this._tempDisplayObjectParent;\n        this.displayObjectUpdateTransform();\n        this.parent = null;\n      } else {\n        this.displayObjectUpdateTransform();\n      }\n    } // don't need to update the lot\n\n\n    return this.worldTransform.apply(position, point);\n  };\n  /**\n   * Calculates the local position of the display object relative to another point.\n   *\n   * @param {PIXI.IPoint} position - The world origin to calculate from.\n   * @param {PIXI.DisplayObject} [from] - The DisplayObject to calculate the global position from.\n   * @param {PIXI.IPoint} [point] - A Point object in which to store the value, optional\n   *  (otherwise will create a new Point).\n   * @param {boolean} [skipUpdate=false] - Should we skip the update transform\n   * @return {PIXI.IPoint} A point object representing the position of this object\n   */\n\n\n  DisplayObject.prototype.toLocal = function toLocal(position, from, point, skipUpdate) {\n    if (from) {\n      position = from.toGlobal(position, point, skipUpdate);\n    }\n\n    if (!skipUpdate) {\n      this._recursivePostUpdateTransform(); // this parent check is for just in case the item is a root object.\n      // If it is we need to give it a temporary parent so that displayObjectUpdateTransform works correctly\n      // this is mainly to avoid a parent check in the main loop. Every little helps for performance :)\n\n\n      if (!this.parent) {\n        this.parent = this._tempDisplayObjectParent;\n        this.displayObjectUpdateTransform();\n        this.parent = null;\n      } else {\n        this.displayObjectUpdateTransform();\n      }\n    } // simply apply the matrix..\n\n\n    return this.worldTransform.applyInverse(position, point);\n  };\n  /**\n   * Renders the object using the WebGL renderer.\n   *\n   * @param {PIXI.Renderer} renderer - The renderer.\n   */\n\n\n  DisplayObject.prototype.render = function render(renderer) // eslint-disable-line no-unused-vars\n  {// OVERWRITE;\n  };\n  /**\n   * Set the parent Container of this DisplayObject.\n   *\n   * @param {PIXI.Container} container - The Container to add this DisplayObject to.\n   * @return {PIXI.Container} The Container that this DisplayObject was added to.\n   */\n\n\n  DisplayObject.prototype.setParent = function setParent(container) {\n    if (!container || !container.addChild) {\n      throw new Error('setParent: Argument must be a Container');\n    }\n\n    container.addChild(this);\n    return container;\n  };\n  /**\n   * Convenience function to set the position, scale, skew and pivot at once.\n   *\n   * @param {number} [x=0] - The X position\n   * @param {number} [y=0] - The Y position\n   * @param {number} [scaleX=1] - The X scale value\n   * @param {number} [scaleY=1] - The Y scale value\n   * @param {number} [rotation=0] - The rotation\n   * @param {number} [skewX=0] - The X skew value\n   * @param {number} [skewY=0] - The Y skew value\n   * @param {number} [pivotX=0] - The X pivot value\n   * @param {number} [pivotY=0] - The Y pivot value\n   * @return {PIXI.DisplayObject} The DisplayObject instance\n   */\n\n\n  DisplayObject.prototype.setTransform = function setTransform(x, y, scaleX, scaleY, rotation, skewX, skewY, pivotX, pivotY) {\n    if (x === void 0) x = 0;\n    if (y === void 0) y = 0;\n    if (scaleX === void 0) scaleX = 1;\n    if (scaleY === void 0) scaleY = 1;\n    if (rotation === void 0) rotation = 0;\n    if (skewX === void 0) skewX = 0;\n    if (skewY === void 0) skewY = 0;\n    if (pivotX === void 0) pivotX = 0;\n    if (pivotY === void 0) pivotY = 0;\n    this.position.x = x;\n    this.position.y = y;\n    this.scale.x = !scaleX ? 1 : scaleX;\n    this.scale.y = !scaleY ? 1 : scaleY;\n    this.rotation = rotation;\n    this.skew.x = skewX;\n    this.skew.y = skewY;\n    this.pivot.x = pivotX;\n    this.pivot.y = pivotY;\n    return this;\n  };\n  /**\n   * Base destroy method for generic display objects. This will automatically\n   * remove the display object from its parent Container as well as remove\n   * all current event listeners and internal references. Do not use a DisplayObject\n   * after calling `destroy()`.\n   *\n   */\n\n\n  DisplayObject.prototype.destroy = function destroy() {\n    if (this.parent) {\n      this.parent.removeChild(this);\n    }\n\n    this.removeAllListeners();\n    this.transform = null;\n    this.parent = null;\n    this._bounds = null;\n    this._currentBounds = null;\n    this._mask = null;\n    this.filters = null;\n    this.filterArea = null;\n    this.hitArea = null;\n    this.interactive = false;\n    this.interactiveChildren = false;\n    this._destroyed = true;\n  };\n  /**\n   * The position of the displayObject on the x axis relative to the local coordinates of the parent.\n   * An alias to position.x\n   *\n   * @member {number}\n   */\n\n\n  prototypeAccessors.x.get = function () {\n    return this.position.x;\n  };\n\n  prototypeAccessors.x.set = function (value) // eslint-disable-line require-jsdoc\n  {\n    this.transform.position.x = value;\n  };\n  /**\n   * The position of the displayObject on the y axis relative to the local coordinates of the parent.\n   * An alias to position.y\n   *\n   * @member {number}\n   */\n\n\n  prototypeAccessors.y.get = function () {\n    return this.position.y;\n  };\n\n  prototypeAccessors.y.set = function (value) // eslint-disable-line require-jsdoc\n  {\n    this.transform.position.y = value;\n  };\n  /**\n   * Current transform of the object based on world (parent) factors.\n   *\n   * @member {PIXI.Matrix}\n   * @readonly\n   */\n\n\n  prototypeAccessors.worldTransform.get = function () {\n    return this.transform.worldTransform;\n  };\n  /**\n   * Current transform of the object based on local factors: position, scale, other stuff.\n   *\n   * @member {PIXI.Matrix}\n   * @readonly\n   */\n\n\n  prototypeAccessors.localTransform.get = function () {\n    return this.transform.localTransform;\n  };\n  /**\n   * The coordinate of the object relative to the local coordinates of the parent.\n   * Assignment by value since pixi-v4.\n   *\n   * @member {PIXI.IPoint}\n   */\n\n\n  prototypeAccessors.position.get = function () {\n    return this.transform.position;\n  };\n\n  prototypeAccessors.position.set = function (value) // eslint-disable-line require-jsdoc\n  {\n    this.transform.position.copyFrom(value);\n  };\n  /**\n   * The scale factor of the object.\n   * Assignment by value since pixi-v4.\n   *\n   * @member {PIXI.IPoint}\n   */\n\n\n  prototypeAccessors.scale.get = function () {\n    return this.transform.scale;\n  };\n\n  prototypeAccessors.scale.set = function (value) // eslint-disable-line require-jsdoc\n  {\n    this.transform.scale.copyFrom(value);\n  };\n  /**\n   * The pivot point of the displayObject that it rotates around.\n   * Assignment by value since pixi-v4.\n   *\n   * @member {PIXI.IPoint}\n   */\n\n\n  prototypeAccessors.pivot.get = function () {\n    return this.transform.pivot;\n  };\n\n  prototypeAccessors.pivot.set = function (value) // eslint-disable-line require-jsdoc\n  {\n    this.transform.pivot.copyFrom(value);\n  };\n  /**\n   * The skew factor for the object in radians.\n   * Assignment by value since pixi-v4.\n   *\n   * @member {PIXI.ObservablePoint}\n   */\n\n\n  prototypeAccessors.skew.get = function () {\n    return this.transform.skew;\n  };\n\n  prototypeAccessors.skew.set = function (value) // eslint-disable-line require-jsdoc\n  {\n    this.transform.skew.copyFrom(value);\n  };\n  /**\n   * The rotation of the object in radians.\n   * 'rotation' and 'angle' have the same effect on a display object; rotation is in radians, angle is in degrees.\n   *\n   * @member {number}\n   */\n\n\n  prototypeAccessors.rotation.get = function () {\n    return this.transform.rotation;\n  };\n\n  prototypeAccessors.rotation.set = function (value) // eslint-disable-line require-jsdoc\n  {\n    this.transform.rotation = value;\n  };\n  /**\n   * The angle of the object in degrees.\n   * 'rotation' and 'angle' have the same effect on a display object; rotation is in radians, angle is in degrees.\n   *\n   * @member {number}\n   */\n\n\n  prototypeAccessors.angle.get = function () {\n    return this.transform.rotation * RAD_TO_DEG;\n  };\n\n  prototypeAccessors.angle.set = function (value) // eslint-disable-line require-jsdoc\n  {\n    this.transform.rotation = value * DEG_TO_RAD;\n  };\n  /**\n   * The zIndex of the displayObject.\n   * If a container has the sortableChildren property set to true, children will be automatically\n   * sorted by zIndex value; a higher value will mean it will be moved towards the end of the array,\n   * and thus rendered on top of other displayObjects within the same container.\n   *\n   * @member {number}\n   */\n\n\n  prototypeAccessors.zIndex.get = function () {\n    return this._zIndex;\n  };\n\n  prototypeAccessors.zIndex.set = function (value) // eslint-disable-line require-jsdoc\n  {\n    this._zIndex = value;\n\n    if (this.parent) {\n      this.parent.sortDirty = true;\n    }\n  };\n  /**\n   * Indicates if the object is globally visible.\n   *\n   * @member {boolean}\n   * @readonly\n   */\n\n\n  prototypeAccessors.worldVisible.get = function () {\n    var item = this;\n\n    do {\n      if (!item.visible) {\n        return false;\n      }\n\n      item = item.parent;\n    } while (item);\n\n    return true;\n  };\n  /**\n   * Sets a mask for the displayObject. A mask is an object that limits the visibility of an\n   * object to the shape of the mask applied to it. In PixiJS a regular mask must be a\n   * {@link PIXI.Graphics} or a {@link PIXI.Sprite} object. This allows for much faster masking in canvas as it\n   * utilities shape clipping. To remove a mask, set this property to `null`.\n   *\n   * For sprite mask both alpha and red channel are used. Black mask is the same as transparent mask.\n   * @example\n   * const graphics = new PIXI.Graphics();\n   * graphics.beginFill(0xFF3300);\n   * graphics.drawRect(50, 250, 100, 100);\n   * graphics.endFill();\n   *\n   * const sprite = new PIXI.Sprite(texture);\n   * sprite.mask = graphics;\n   * @todo At the moment, PIXI.CanvasRenderer doesn't support PIXI.Sprite as mask.\n   *\n   * @member {PIXI.Container|PIXI.MaskData}\n   */\n\n\n  prototypeAccessors.mask.get = function () {\n    return this._mask;\n  };\n\n  prototypeAccessors.mask.set = function (value) // eslint-disable-line require-jsdoc\n  {\n    if (this._mask) {\n      var maskObject = this._mask.maskObject || this._mask;\n      maskObject.renderable = true;\n      maskObject.isMask = false;\n    }\n\n    this._mask = value;\n\n    if (this._mask) {\n      var maskObject$1 = this._mask.maskObject || this._mask;\n      maskObject$1.renderable = false;\n      maskObject$1.isMask = true;\n    }\n  };\n\n  Object.defineProperties(DisplayObject.prototype, prototypeAccessors);\n  return DisplayObject;\n}(EventEmitter);\n/**\n * DisplayObject default updateTransform, does not update children of container.\n * Will crash if there's no parent element.\n *\n * @memberof PIXI.DisplayObject#\n * @function displayObjectUpdateTransform\n */\n\n\nDisplayObject.prototype.displayObjectUpdateTransform = DisplayObject.prototype.updateTransform;\n\nfunction sortChildren(a, b) {\n  if (a.zIndex === b.zIndex) {\n    return a._lastSortedIndex - b._lastSortedIndex;\n  }\n\n  return a.zIndex - b.zIndex;\n}\n/**\n * A Container represents a collection of display objects.\n *\n * It is the base class of all display objects that act as a container for other objects (like Sprites).\n *\n *```js\n * let container = new PIXI.Container();\n * container.addChild(sprite);\n * ```\n *\n * @class\n * @extends PIXI.DisplayObject\n * @memberof PIXI\n */\n\n\nvar Container =\n/*@__PURE__*/\nfunction (DisplayObject) {\n  function Container() {\n    DisplayObject.call(this);\n    /**\n     * The array of children of this container.\n     *\n     * @member {PIXI.DisplayObject[]}\n     * @readonly\n     */\n\n    this.children = [];\n    /**\n     * If set to true, the container will sort its children by zIndex value\n     * when updateTransform() is called, or manually if sortChildren() is called.\n     *\n     * This actually changes the order of elements in the array, so should be treated\n     * as a basic solution that is not performant compared to other solutions,\n     * such as @link https://github.com/pixijs/pixi-display\n     *\n     * Also be aware of that this may not work nicely with the addChildAt() function,\n     * as the zIndex sorting may cause the child to automatically sorted to another position.\n     *\n     * @see PIXI.settings.SORTABLE_CHILDREN\n     *\n     * @member {boolean}\n     */\n\n    this.sortableChildren = settings.SORTABLE_CHILDREN;\n    /**\n     * Should children be sorted by zIndex at the next updateTransform call.\n     * Will get automatically set to true if a new child is added, or if a child's zIndex changes.\n     *\n     * @member {boolean}\n     */\n\n    this.sortDirty = false;\n    /**\n     * Fired when a DisplayObject is added to this Container.\n     *\n     * @event PIXI.Container#childAdded\n     * @param {PIXI.DisplayObject} child - The child added to the Container.\n     * @param {PIXI.Container} container - The container that added the child.\n     * @param {number} index - The children's index of the added child.\n     */\n\n    /**\n     * Fired when a DisplayObject is removed from this Container.\n     *\n     * @event PIXI.DisplayObject#removedFrom\n     * @param {PIXI.DisplayObject} child - The child removed from the Container.\n     * @param {PIXI.Container} container - The container that removed removed the child.\n     * @param {number} index - The former children's index of the removed child\n     */\n  }\n\n  if (DisplayObject) Container.__proto__ = DisplayObject;\n  Container.prototype = Object.create(DisplayObject && DisplayObject.prototype);\n  Container.prototype.constructor = Container;\n  var prototypeAccessors = {\n    width: {\n      configurable: true\n    },\n    height: {\n      configurable: true\n    }\n  };\n  /**\n   * Overridable method that can be used by Container subclasses whenever the children array is modified\n   *\n   * @protected\n   */\n\n  Container.prototype.onChildrenChange = function onChildrenChange() {\n    /* empty */\n  };\n  /**\n   * Adds one or more children to the container.\n   *\n   * Multiple items can be added like so: `myContainer.addChild(thingOne, thingTwo, thingThree)`\n   *\n   * @param {...PIXI.DisplayObject} child - The DisplayObject(s) to add to the container\n   * @return {PIXI.DisplayObject} The first child that was added.\n   */\n\n\n  Container.prototype.addChild = function addChild(child) {\n    var arguments$1 = arguments;\n    var argumentsLength = arguments.length; // if there is only one argument we can bypass looping through the them\n\n    if (argumentsLength > 1) {\n      // loop through the arguments property and add all children\n      // use it the right way (.length and [i]) so that this function can still be optimized by JS runtimes\n      for (var i = 0; i < argumentsLength; i++) {\n        this.addChild(arguments$1[i]);\n      }\n    } else {\n      // if the child has a parent then lets remove it as PixiJS objects can only exist in one place\n      if (child.parent) {\n        child.parent.removeChild(child);\n      }\n\n      child.parent = this;\n      this.sortDirty = true; // ensure child transform will be recalculated\n\n      child.transform._parentID = -1;\n      this.children.push(child); // ensure bounds will be recalculated\n\n      this._boundsID++; // TODO - lets either do all callbacks or all events.. not both!\n\n      this.onChildrenChange(this.children.length - 1);\n      this.emit('childAdded', child, this, this.children.length - 1);\n      child.emit('added', this);\n    }\n\n    return child;\n  };\n  /**\n   * Adds a child to the container at a specified index. If the index is out of bounds an error will be thrown\n   *\n   * @param {PIXI.DisplayObject} child - The child to add\n   * @param {number} index - The index to place the child in\n   * @return {PIXI.DisplayObject} The child that was added.\n   */\n\n\n  Container.prototype.addChildAt = function addChildAt(child, index) {\n    if (index < 0 || index > this.children.length) {\n      throw new Error(child + \"addChildAt: The index \" + index + \" supplied is out of bounds \" + this.children.length);\n    }\n\n    if (child.parent) {\n      child.parent.removeChild(child);\n    }\n\n    child.parent = this;\n    this.sortDirty = true; // ensure child transform will be recalculated\n\n    child.transform._parentID = -1;\n    this.children.splice(index, 0, child); // ensure bounds will be recalculated\n\n    this._boundsID++; // TODO - lets either do all callbacks or all events.. not both!\n\n    this.onChildrenChange(index);\n    child.emit('added', this);\n    this.emit('childAdded', child, this, index);\n    return child;\n  };\n  /**\n   * Swaps the position of 2 Display Objects within this container.\n   *\n   * @param {PIXI.DisplayObject} child - First display object to swap\n   * @param {PIXI.DisplayObject} child2 - Second display object to swap\n   */\n\n\n  Container.prototype.swapChildren = function swapChildren(child, child2) {\n    if (child === child2) {\n      return;\n    }\n\n    var index1 = this.getChildIndex(child);\n    var index2 = this.getChildIndex(child2);\n    this.children[index1] = child2;\n    this.children[index2] = child;\n    this.onChildrenChange(index1 < index2 ? index1 : index2);\n  };\n  /**\n   * Returns the index position of a child DisplayObject instance\n   *\n   * @param {PIXI.DisplayObject} child - The DisplayObject instance to identify\n   * @return {number} The index position of the child display object to identify\n   */\n\n\n  Container.prototype.getChildIndex = function getChildIndex(child) {\n    var index = this.children.indexOf(child);\n\n    if (index === -1) {\n      throw new Error('The supplied DisplayObject must be a child of the caller');\n    }\n\n    return index;\n  };\n  /**\n   * Changes the position of an existing child in the display object container\n   *\n   * @param {PIXI.DisplayObject} child - The child DisplayObject instance for which you want to change the index number\n   * @param {number} index - The resulting index number for the child display object\n   */\n\n\n  Container.prototype.setChildIndex = function setChildIndex(child, index) {\n    if (index < 0 || index >= this.children.length) {\n      throw new Error(\"The index \" + index + \" supplied is out of bounds \" + this.children.length);\n    }\n\n    var currentIndex = this.getChildIndex(child);\n    removeItems(this.children, currentIndex, 1); // remove from old position\n\n    this.children.splice(index, 0, child); // add at new position\n\n    this.onChildrenChange(index);\n  };\n  /**\n   * Returns the child at the specified index\n   *\n   * @param {number} index - The index to get the child at\n   * @return {PIXI.DisplayObject} The child at the given index, if any.\n   */\n\n\n  Container.prototype.getChildAt = function getChildAt(index) {\n    if (index < 0 || index >= this.children.length) {\n      throw new Error(\"getChildAt: Index (\" + index + \") does not exist.\");\n    }\n\n    return this.children[index];\n  };\n  /**\n   * Removes one or more children from the container.\n   *\n   * @param {...PIXI.DisplayObject} child - The DisplayObject(s) to remove\n   * @return {PIXI.DisplayObject} The first child that was removed.\n   */\n\n\n  Container.prototype.removeChild = function removeChild(child) {\n    var arguments$1 = arguments;\n    var argumentsLength = arguments.length; // if there is only one argument we can bypass looping through the them\n\n    if (argumentsLength > 1) {\n      // loop through the arguments property and add all children\n      // use it the right way (.length and [i]) so that this function can still be optimized by JS runtimes\n      for (var i = 0; i < argumentsLength; i++) {\n        this.removeChild(arguments$1[i]);\n      }\n    } else {\n      var index = this.children.indexOf(child);\n\n      if (index === -1) {\n        return null;\n      }\n\n      child.parent = null; // ensure child transform will be recalculated\n\n      child.transform._parentID = -1;\n      removeItems(this.children, index, 1); // ensure bounds will be recalculated\n\n      this._boundsID++; // TODO - lets either do all callbacks or all events.. not both!\n\n      this.onChildrenChange(index);\n      child.emit('removed', this);\n      this.emit('childRemoved', child, this, index);\n    }\n\n    return child;\n  };\n  /**\n   * Removes a child from the specified index position.\n   *\n   * @param {number} index - The index to get the child from\n   * @return {PIXI.DisplayObject} The child that was removed.\n   */\n\n\n  Container.prototype.removeChildAt = function removeChildAt(index) {\n    var child = this.getChildAt(index); // ensure child transform will be recalculated..\n\n    child.parent = null;\n    child.transform._parentID = -1;\n    removeItems(this.children, index, 1); // ensure bounds will be recalculated\n\n    this._boundsID++; // TODO - lets either do all callbacks or all events.. not both!\n\n    this.onChildrenChange(index);\n    child.emit('removed', this);\n    this.emit('childRemoved', child, this, index);\n    return child;\n  };\n  /**\n   * Removes all children from this container that are within the begin and end indexes.\n   *\n   * @param {number} [beginIndex=0] - The beginning position.\n   * @param {number} [endIndex=this.children.length] - The ending position. Default value is size of the container.\n   * @returns {PIXI.DisplayObject[]} List of removed children\n   */\n\n\n  Container.prototype.removeChildren = function removeChildren(beginIndex, endIndex) {\n    if (beginIndex === void 0) beginIndex = 0;\n    var begin = beginIndex;\n    var end = typeof endIndex === 'number' ? endIndex : this.children.length;\n    var range = end - begin;\n    var removed;\n\n    if (range > 0 && range <= end) {\n      removed = this.children.splice(begin, range);\n\n      for (var i = 0; i < removed.length; ++i) {\n        removed[i].parent = null;\n\n        if (removed[i].transform) {\n          removed[i].transform._parentID = -1;\n        }\n      }\n\n      this._boundsID++;\n      this.onChildrenChange(beginIndex);\n\n      for (var i$1 = 0; i$1 < removed.length; ++i$1) {\n        removed[i$1].emit('removed', this);\n        this.emit('childRemoved', removed[i$1], this, i$1);\n      }\n\n      return removed;\n    } else if (range === 0 && this.children.length === 0) {\n      return [];\n    }\n\n    throw new RangeError('removeChildren: numeric values are outside the acceptable range.');\n  };\n  /**\n   * Sorts children by zIndex. Previous order is mantained for 2 children with the same zIndex.\n   */\n\n\n  Container.prototype.sortChildren = function sortChildren$1() {\n    var sortRequired = false;\n\n    for (var i = 0, j = this.children.length; i < j; ++i) {\n      var child = this.children[i];\n      child._lastSortedIndex = i;\n\n      if (!sortRequired && child.zIndex !== 0) {\n        sortRequired = true;\n      }\n    }\n\n    if (sortRequired && this.children.length > 1) {\n      this.children.sort(sortChildren);\n    }\n\n    this.sortDirty = false;\n  };\n  /**\n   * Updates the transform on all children of this container for rendering\n   */\n\n\n  Container.prototype.updateTransform = function updateTransform() {\n    if (this.sortableChildren && this.sortDirty) {\n      this.sortChildren();\n    }\n\n    this._boundsID++;\n    this.transform.updateTransform(this.parent.transform); // TODO: check render flags, how to process stuff here\n\n    this.worldAlpha = this.alpha * this.parent.worldAlpha;\n\n    for (var i = 0, j = this.children.length; i < j; ++i) {\n      var child = this.children[i];\n\n      if (child.visible) {\n        child.updateTransform();\n      }\n    }\n  };\n  /**\n   * Recalculates the bounds of the container.\n   *\n   */\n\n\n  Container.prototype.calculateBounds = function calculateBounds() {\n    this._bounds.clear();\n\n    this._calculateBounds();\n\n    for (var i = 0; i < this.children.length; i++) {\n      var child = this.children[i];\n\n      if (!child.visible || !child.renderable) {\n        continue;\n      }\n\n      child.calculateBounds(); // TODO: filter+mask, need to mask both somehow\n\n      if (child._mask) {\n        var maskObject = child._mask.maskObject || child._mask;\n        maskObject.calculateBounds();\n\n        this._bounds.addBoundsMask(child._bounds, maskObject._bounds);\n      } else if (child.filterArea) {\n        this._bounds.addBoundsArea(child._bounds, child.filterArea);\n      } else {\n        this._bounds.addBounds(child._bounds);\n      }\n    }\n\n    this._lastBoundsID = this._boundsID;\n  };\n  /**\n   * Recalculates the bounds of the object. Override this to\n   * calculate the bounds of the specific object (not including children).\n   *\n   * @protected\n   */\n\n\n  Container.prototype._calculateBounds = function _calculateBounds() {// FILL IN//\n  };\n  /**\n   * Renders the object using the WebGL renderer\n   *\n   * @param {PIXI.Renderer} renderer - The renderer\n   */\n\n\n  Container.prototype.render = function render(renderer) {\n    // if the object is not visible or the alpha is 0 then no need to render this element\n    if (!this.visible || this.worldAlpha <= 0 || !this.renderable) {\n      return;\n    } // do a quick check to see if this element has a mask or a filter.\n\n\n    if (this._mask || this.filters && this.filters.length) {\n      this.renderAdvanced(renderer);\n    } else {\n      this._render(renderer); // simple render children!\n\n\n      for (var i = 0, j = this.children.length; i < j; ++i) {\n        this.children[i].render(renderer);\n      }\n    }\n  };\n  /**\n   * Render the object using the WebGL renderer and advanced features.\n   *\n   * @protected\n   * @param {PIXI.Renderer} renderer - The renderer\n   */\n\n\n  Container.prototype.renderAdvanced = function renderAdvanced(renderer) {\n    renderer.batch.flush();\n    var filters = this.filters;\n    var mask = this._mask; // push filter first as we need to ensure the stencil buffer is correct for any masking\n\n    if (filters) {\n      if (!this._enabledFilters) {\n        this._enabledFilters = [];\n      }\n\n      this._enabledFilters.length = 0;\n\n      for (var i = 0; i < filters.length; i++) {\n        if (filters[i].enabled) {\n          this._enabledFilters.push(filters[i]);\n        }\n      }\n\n      if (this._enabledFilters.length) {\n        renderer.filter.push(this, this._enabledFilters);\n      }\n    }\n\n    if (mask) {\n      renderer.mask.push(this, this._mask);\n    } // add this object to the batch, only rendered if it has a texture.\n\n\n    this._render(renderer); // now loop through the children and make sure they get rendered\n\n\n    for (var i$1 = 0, j = this.children.length; i$1 < j; i$1++) {\n      this.children[i$1].render(renderer);\n    }\n\n    renderer.batch.flush();\n\n    if (mask) {\n      renderer.mask.pop(this, this._mask);\n    }\n\n    if (filters && this._enabledFilters && this._enabledFilters.length) {\n      renderer.filter.pop();\n    }\n  };\n  /**\n   * To be overridden by the subclasses.\n   *\n   * @protected\n   * @param {PIXI.Renderer} renderer - The renderer\n   */\n\n\n  Container.prototype._render = function _render(renderer) // eslint-disable-line no-unused-vars\n  {// this is where content itself gets rendered...\n  };\n  /**\n   * Removes all internal references and listeners as well as removes children from the display list.\n   * Do not use a Container after calling `destroy`.\n   *\n   * @param {object|boolean} [options] - Options parameter. A boolean will act as if all options\n   *  have been set to that value\n   * @param {boolean} [options.children=false] - if set to true, all the children will have their destroy\n   *  method called as well. 'options' will be passed on to those calls.\n   * @param {boolean} [options.texture=false] - Only used for child Sprites if options.children is set to true\n   *  Should it destroy the texture of the child sprite\n   * @param {boolean} [options.baseTexture=false] - Only used for child Sprites if options.children is set to true\n   *  Should it destroy the base texture of the child sprite\n   */\n\n\n  Container.prototype.destroy = function destroy(options) {\n    DisplayObject.prototype.destroy.call(this);\n    this.sortDirty = false;\n    var destroyChildren = typeof options === 'boolean' ? options : options && options.children;\n    var oldChildren = this.removeChildren(0, this.children.length);\n\n    if (destroyChildren) {\n      for (var i = 0; i < oldChildren.length; ++i) {\n        oldChildren[i].destroy(options);\n      }\n    }\n  };\n  /**\n   * The width of the Container, setting this will actually modify the scale to achieve the value set\n   *\n   * @member {number}\n   */\n\n\n  prototypeAccessors.width.get = function () {\n    return this.scale.x * this.getLocalBounds().width;\n  };\n\n  prototypeAccessors.width.set = function (value) // eslint-disable-line require-jsdoc\n  {\n    var width = this.getLocalBounds().width;\n\n    if (width !== 0) {\n      this.scale.x = value / width;\n    } else {\n      this.scale.x = 1;\n    }\n\n    this._width = value;\n  };\n  /**\n   * The height of the Container, setting this will actually modify the scale to achieve the value set\n   *\n   * @member {number}\n   */\n\n\n  prototypeAccessors.height.get = function () {\n    return this.scale.y * this.getLocalBounds().height;\n  };\n\n  prototypeAccessors.height.set = function (value) // eslint-disable-line require-jsdoc\n  {\n    var height = this.getLocalBounds().height;\n\n    if (height !== 0) {\n      this.scale.y = value / height;\n    } else {\n      this.scale.y = 1;\n    }\n\n    this._height = value;\n  };\n\n  Object.defineProperties(Container.prototype, prototypeAccessors);\n  return Container;\n}(DisplayObject); // performance increase to avoid using call.. (10x faster)\n\n\nContainer.prototype.containerUpdateTransform = Container.prototype.updateTransform;\nexport { Bounds, Container, DisplayObject };","map":{"version":3,"sources":["../src/settings.js","../src/Bounds.js","../src/DisplayObject.js","../src/Container.js"],"names":["let","const","super","maskObject","arguments","i"],"mappings":"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","sourcesContent":["import { settings } from '@pixi/settings';\n\n/**\n * Sets the default value for the container property 'sortableChildren'.\n * If set to true, the container will sort its children by zIndex value\n * when updateTransform() is called, or manually if sortChildren() is called.\n *\n * This actually changes the order of elements in the array, so should be treated\n * as a basic solution that is not performant compared to other solutions,\n * such as @link https://github.com/pixijs/pixi-display\n *\n * Also be aware of that this may not work nicely with the addChildAt() function,\n * as the zIndex sorting may cause the child to automatically sorted to another position.\n *\n * @static\n * @constant\n * @name SORTABLE_CHILDREN\n * @memberof PIXI.settings\n * @type {boolean}\n * @default false\n */\nsettings.SORTABLE_CHILDREN = false;\n\nexport { settings };\n","import { Rectangle } from '@pixi/math';\n\n/**\n * 'Builder' pattern for bounds rectangles.\n *\n * This could be called an Axis-Aligned Bounding Box.\n * It is not an actual shape. It is a mutable thing; no 'EMPTY' or those kind of problems.\n *\n * @class\n * @memberof PIXI\n */\nexport class Bounds\n{\n    constructor()\n    {\n        /**\n         * @member {number}\n         * @default 0\n         */\n        this.minX = Infinity;\n\n        /**\n         * @member {number}\n         * @default 0\n         */\n        this.minY = Infinity;\n\n        /**\n         * @member {number}\n         * @default 0\n         */\n        this.maxX = -Infinity;\n\n        /**\n         * @member {number}\n         * @default 0\n         */\n        this.maxY = -Infinity;\n\n        this.rect = null;\n    }\n\n    /**\n     * Checks if bounds are empty.\n     *\n     * @return {boolean} True if empty.\n     */\n    isEmpty()\n    {\n        return this.minX > this.maxX || this.minY > this.maxY;\n    }\n\n    /**\n     * Clears the bounds and resets.\n     *\n     */\n    clear()\n    {\n        this.minX = Infinity;\n        this.minY = Infinity;\n        this.maxX = -Infinity;\n        this.maxY = -Infinity;\n    }\n\n    /**\n     * Can return Rectangle.EMPTY constant, either construct new rectangle, either use your rectangle\n     * It is not guaranteed that it will return tempRect\n     *\n     * @param {PIXI.Rectangle} rect - temporary object will be used if AABB is not empty\n     * @returns {PIXI.Rectangle} A rectangle of the bounds\n     */\n    getRectangle(rect)\n    {\n        if (this.minX > this.maxX || this.minY > this.maxY)\n        {\n            return Rectangle.EMPTY;\n        }\n\n        rect = rect || new Rectangle(0, 0, 1, 1);\n\n        rect.x = this.minX;\n        rect.y = this.minY;\n        rect.width = this.maxX - this.minX;\n        rect.height = this.maxY - this.minY;\n\n        return rect;\n    }\n\n    /**\n     * This function should be inlined when its possible.\n     *\n     * @param {PIXI.Point} point - The point to add.\n     */\n    addPoint(point)\n    {\n        this.minX = Math.min(this.minX, point.x);\n        this.maxX = Math.max(this.maxX, point.x);\n        this.minY = Math.min(this.minY, point.y);\n        this.maxY = Math.max(this.maxY, point.y);\n    }\n\n    /**\n     * Adds a quad, not transformed\n     *\n     * @param {Float32Array} vertices - The verts to add.\n     */\n    addQuad(vertices)\n    {\n        let minX = this.minX;\n        let minY = this.minY;\n        let maxX = this.maxX;\n        let maxY = this.maxY;\n\n        let x = vertices[0];\n        let y = vertices[1];\n\n        minX = x < minX ? x : minX;\n        minY = y < minY ? y : minY;\n        maxX = x > maxX ? x : maxX;\n        maxY = y > maxY ? y : maxY;\n\n        x = vertices[2];\n        y = vertices[3];\n        minX = x < minX ? x : minX;\n        minY = y < minY ? y : minY;\n        maxX = x > maxX ? x : maxX;\n        maxY = y > maxY ? y : maxY;\n\n        x = vertices[4];\n        y = vertices[5];\n        minX = x < minX ? x : minX;\n        minY = y < minY ? y : minY;\n        maxX = x > maxX ? x : maxX;\n        maxY = y > maxY ? y : maxY;\n\n        x = vertices[6];\n        y = vertices[7];\n        minX = x < minX ? x : minX;\n        minY = y < minY ? y : minY;\n        maxX = x > maxX ? x : maxX;\n        maxY = y > maxY ? y : maxY;\n\n        this.minX = minX;\n        this.minY = minY;\n        this.maxX = maxX;\n        this.maxY = maxY;\n    }\n\n    /**\n     * Adds sprite frame, transformed.\n     *\n     * @param {PIXI.Transform} transform - transform to apply\n     * @param {number} x0 - left X of frame\n     * @param {number} y0 - top Y of frame\n     * @param {number} x1 - right X of frame\n     * @param {number} y1 - bottom Y of frame\n     */\n    addFrame(transform, x0, y0, x1, y1)\n    {\n        this.addFrameMatrix(transform.worldTransform, x0, y0, x1, y1);\n    }\n\n    /**\n     * Adds sprite frame, multiplied by matrix\n     *\n     * @param {PIXI.Matrix} matrix - matrix to apply\n     * @param {number} x0 - left X of frame\n     * @param {number} y0 - top Y of frame\n     * @param {number} x1 - right X of frame\n     * @param {number} y1 - bottom Y of frame\n     */\n    addFrameMatrix(matrix, x0, y0, x1, y1)\n    {\n        const a = matrix.a;\n        const b = matrix.b;\n        const c = matrix.c;\n        const d = matrix.d;\n        const tx = matrix.tx;\n        const ty = matrix.ty;\n\n        let minX = this.minX;\n        let minY = this.minY;\n        let maxX = this.maxX;\n        let maxY = this.maxY;\n\n        let x = (a * x0) + (c * y0) + tx;\n        let y = (b * x0) + (d * y0) + ty;\n\n        minX = x < minX ? x : minX;\n        minY = y < minY ? y : minY;\n        maxX = x > maxX ? x : maxX;\n        maxY = y > maxY ? y : maxY;\n\n        x = (a * x1) + (c * y0) + tx;\n        y = (b * x1) + (d * y0) + ty;\n        minX = x < minX ? x : minX;\n        minY = y < minY ? y : minY;\n        maxX = x > maxX ? x : maxX;\n        maxY = y > maxY ? y : maxY;\n\n        x = (a * x0) + (c * y1) + tx;\n        y = (b * x0) + (d * y1) + ty;\n        minX = x < minX ? x : minX;\n        minY = y < minY ? y : minY;\n        maxX = x > maxX ? x : maxX;\n        maxY = y > maxY ? y : maxY;\n\n        x = (a * x1) + (c * y1) + tx;\n        y = (b * x1) + (d * y1) + ty;\n        minX = x < minX ? x : minX;\n        minY = y < minY ? y : minY;\n        maxX = x > maxX ? x : maxX;\n        maxY = y > maxY ? y : maxY;\n\n        this.minX = minX;\n        this.minY = minY;\n        this.maxX = maxX;\n        this.maxY = maxY;\n    }\n\n    /**\n     * Adds screen vertices from array\n     *\n     * @param {Float32Array} vertexData - calculated vertices\n     * @param {number} beginOffset - begin offset\n     * @param {number} endOffset - end offset, excluded\n     */\n    addVertexData(vertexData, beginOffset, endOffset)\n    {\n        let minX = this.minX;\n        let minY = this.minY;\n        let maxX = this.maxX;\n        let maxY = this.maxY;\n\n        for (let i = beginOffset; i < endOffset; i += 2)\n        {\n            const x = vertexData[i];\n            const y = vertexData[i + 1];\n\n            minX = x < minX ? x : minX;\n            minY = y < minY ? y : minY;\n            maxX = x > maxX ? x : maxX;\n            maxY = y > maxY ? y : maxY;\n        }\n\n        this.minX = minX;\n        this.minY = minY;\n        this.maxX = maxX;\n        this.maxY = maxY;\n    }\n\n    /**\n     * Add an array of mesh vertices\n     *\n     * @param {PIXI.Transform} transform - mesh transform\n     * @param {Float32Array} vertices - mesh coordinates in array\n     * @param {number} beginOffset - begin offset\n     * @param {number} endOffset - end offset, excluded\n     */\n    addVertices(transform, vertices, beginOffset, endOffset)\n    {\n        this.addVerticesMatrix(transform.worldTransform, vertices, beginOffset, endOffset);\n    }\n\n    /**\n     * Add an array of mesh vertices\n     *\n     * @param {PIXI.Matrix} matrix - mesh matrix\n     * @param {Float32Array} vertices - mesh coordinates in array\n     * @param {number} beginOffset - begin offset\n     * @param {number} endOffset - end offset, excluded\n     * @param {number} [padX] - x padding\n     * @param {number} [padY] - y padding\n     */\n    addVerticesMatrix(matrix, vertices, beginOffset, endOffset, padX, padY)\n    {\n        const a = matrix.a;\n        const b = matrix.b;\n        const c = matrix.c;\n        const d = matrix.d;\n        const tx = matrix.tx;\n        const ty = matrix.ty;\n\n        padX = padX || 0;\n        padY = padY || 0;\n\n        let minX = this.minX;\n        let minY = this.minY;\n        let maxX = this.maxX;\n        let maxY = this.maxY;\n\n        for (let i = beginOffset; i < endOffset; i += 2)\n        {\n            const rawX = vertices[i];\n            const rawY = vertices[i + 1];\n            const x = (a * rawX) + (c * rawY) + tx;\n            const y = (d * rawY) + (b * rawX) + ty;\n\n            minX = Math.min(minX, x - padX);\n            maxX = Math.max(maxX, x + padX);\n            minY = Math.min(minY, y - padY);\n            maxY = Math.max(maxY, y + padY);\n        }\n\n        this.minX = minX;\n        this.minY = minY;\n        this.maxX = maxX;\n        this.maxY = maxY;\n    }\n\n    /**\n     * Adds other Bounds\n     *\n     * @param {PIXI.Bounds} bounds - TODO\n     */\n    addBounds(bounds)\n    {\n        const minX = this.minX;\n        const minY = this.minY;\n        const maxX = this.maxX;\n        const maxY = this.maxY;\n\n        this.minX = bounds.minX < minX ? bounds.minX : minX;\n        this.minY = bounds.minY < minY ? bounds.minY : minY;\n        this.maxX = bounds.maxX > maxX ? bounds.maxX : maxX;\n        this.maxY = bounds.maxY > maxY ? bounds.maxY : maxY;\n    }\n\n    /**\n     * Adds other Bounds, masked with Bounds\n     *\n     * @param {PIXI.Bounds} bounds - TODO\n     * @param {PIXI.Bounds} mask - TODO\n     */\n    addBoundsMask(bounds, mask)\n    {\n        const _minX = bounds.minX > mask.minX ? bounds.minX : mask.minX;\n        const _minY = bounds.minY > mask.minY ? bounds.minY : mask.minY;\n        const _maxX = bounds.maxX < mask.maxX ? bounds.maxX : mask.maxX;\n        const _maxY = bounds.maxY < mask.maxY ? bounds.maxY : mask.maxY;\n\n        if (_minX <= _maxX && _minY <= _maxY)\n        {\n            const minX = this.minX;\n            const minY = this.minY;\n            const maxX = this.maxX;\n            const maxY = this.maxY;\n\n            this.minX = _minX < minX ? _minX : minX;\n            this.minY = _minY < minY ? _minY : minY;\n            this.maxX = _maxX > maxX ? _maxX : maxX;\n            this.maxY = _maxY > maxY ? _maxY : maxY;\n        }\n    }\n\n    /**\n     * Adds other Bounds, multiplied by matrix. Bounds shouldn't be empty\n     *\n     * @param {PIXI.Bounds} bounds other bounds\n     * @param {PIXI.Matrix} matrix multiplicator\n     */\n    addBoundsMatrix(bounds, matrix)\n    {\n        this.addFrameMatrix(matrix, bounds.minX, bounds.minY, bounds.maxX, bounds.maxY);\n    }\n\n    /**\n     * Adds other Bounds, masked with Rectangle\n     *\n     * @param {PIXI.Bounds} bounds - TODO\n     * @param {PIXI.Rectangle} area - TODO\n     */\n    addBoundsArea(bounds, area)\n    {\n        const _minX = bounds.minX > area.x ? bounds.minX : area.x;\n        const _minY = bounds.minY > area.y ? bounds.minY : area.y;\n        const _maxX = bounds.maxX < area.x + area.width ? bounds.maxX : (area.x + area.width);\n        const _maxY = bounds.maxY < area.y + area.height ? bounds.maxY : (area.y + area.height);\n\n        if (_minX <= _maxX && _minY <= _maxY)\n        {\n            const minX = this.minX;\n            const minY = this.minY;\n            const maxX = this.maxX;\n            const maxY = this.maxY;\n\n            this.minX = _minX < minX ? _minX : minX;\n            this.minY = _minY < minY ? _minY : minY;\n            this.maxX = _maxX > maxX ? _maxX : maxX;\n            this.maxY = _maxY > maxY ? _maxY : maxY;\n        }\n    }\n\n    /**\n     * Pads bounds object, making it grow in all directions.\n     * If paddingY is omitted, both paddingX and paddingY will be set to paddingX.\n     *\n     * @param {number} [paddingX=0] - The horizontal padding amount.\n     * @param {number} [paddingY=0] - The vertical padding amount.\n     */\n    pad(paddingX, paddingY)\n    {\n        paddingX = paddingX || 0;\n        paddingY = paddingY || ((paddingY !== 0) ? paddingX : 0);\n\n        if (!this.isEmpty())\n        {\n            this.minX -= paddingX;\n            this.maxX += paddingX;\n            this.minY -= paddingY;\n            this.maxY += paddingY;\n        }\n    }\n\n    /**\n     * Adds padded frame. (x0, y0) should be strictly less than (x1, y1)\n     *\n     * @param {number} x0 - left X of frame\n     * @param {number} y0 - top Y of frame\n     * @param {number} x1 - right X of frame\n     * @param {number} y1 - bottom Y of frame\n     * @param {number} padX - padding X\n     * @param {number} padY - padding Y\n     */\n    addFramePad(x0, y0, x1, y1, padX, padY)\n    {\n        x0 -= padX;\n        y0 -= padY;\n        x1 += padX;\n        y1 += padY;\n\n        this.minX = this.minX < x0 ? this.minX : x0;\n        this.maxX = this.maxX > x1 ? this.maxX : x1;\n        this.minY = this.minY < y0 ? this.minY : y0;\n        this.maxY = this.maxY > y1 ? this.maxY : y1;\n    }\n}\n","import { EventEmitter } from '@pixi/utils';\nimport { Rectangle, Transform, RAD_TO_DEG, DEG_TO_RAD } from '@pixi/math';\nimport { Bounds } from './Bounds';\n// _tempDisplayObjectParent = new DisplayObject();\n\n/**\n * The base class for all objects that are rendered on the screen.\n *\n * This is an abstract class and should not be used on its own; rather it should be extended.\n *\n * @class\n * @extends PIXI.utils.EventEmitter\n * @memberof PIXI\n */\nexport class DisplayObject extends EventEmitter\n{\n    /**\n     * Mixes all enumerable properties and methods from a source object to DisplayObject.\n     *\n     * @param {object} source The source of properties and methods to mix in.\n     */\n    static mixin(source)\n    {\n        // in ES8/ES2017, this would be really easy:\n        // Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n\n        // get all the enumerable property keys\n        const keys = Object.keys(source);\n\n        // loop through properties\n        for (let i = 0; i < keys.length; ++i)\n        {\n            const propertyName = keys[i];\n\n            // Set the property using the property descriptor - this works for accessors and normal value properties\n            Object.defineProperty(\n                DisplayObject.prototype,\n                propertyName,\n                Object.getOwnPropertyDescriptor(source, propertyName)\n            );\n        }\n    }\n\n    constructor()\n    {\n        super();\n\n        this.tempDisplayObjectParent = null;\n\n        // TODO: need to create Transform from factory\n        /**\n         * World transform and local transform of this object.\n         * This will become read-only later, please do not assign anything there unless you know what are you doing.\n         *\n         * @member {PIXI.Transform}\n         */\n        this.transform = new Transform();\n\n        /**\n         * The opacity of the object.\n         *\n         * @member {number}\n         */\n        this.alpha = 1;\n\n        /**\n         * The visibility of the object. If false the object will not be drawn, and\n         * the updateTransform function will not be called.\n         *\n         * Only affects recursive calls from parent. You can ask for bounds or call updateTransform manually.\n         *\n         * @member {boolean}\n         */\n        this.visible = true;\n\n        /**\n         * Can this object be rendered, if false the object will not be drawn but the updateTransform\n         * methods will still be called.\n         *\n         * Only affects recursive calls from parent. You can ask for bounds manually.\n         *\n         * @member {boolean}\n         */\n        this.renderable = true;\n\n        /**\n         * The display object container that contains this display object.\n         *\n         * @member {PIXI.Container}\n         * @readonly\n         */\n        this.parent = null;\n\n        /**\n         * The multiplied alpha of the displayObject.\n         *\n         * @member {number}\n         * @readonly\n         */\n        this.worldAlpha = 1;\n\n        /**\n         * Which index in the children array the display component was before the previous zIndex sort.\n         * Used by containers to help sort objects with the same zIndex, by using previous array index as the decider.\n         *\n         * @member {number}\n         * @protected\n         */\n        this._lastSortedIndex = 0;\n\n        /**\n         * The zIndex of the displayObject.\n         * A higher value will mean it will be rendered on top of other displayObjects within the same container.\n         *\n         * @member {number}\n         * @protected\n         */\n        this._zIndex = 0;\n\n        /**\n         * The area the filter is applied to. This is used as more of an optimization\n         * rather than figuring out the dimensions of the displayObject each frame you can set this rectangle.\n         *\n         * Also works as an interaction mask.\n         *\n         * @member {?PIXI.Rectangle}\n         */\n        this.filterArea = null;\n\n        /**\n         * Sets the filters for the displayObject.\n         * * IMPORTANT: This is a WebGL only feature and will be ignored by the canvas renderer.\n         * To remove filters simply set this property to `'null'`.\n         *\n         * @member {?PIXI.Filter[]}\n         */\n        this.filters = null;\n        this._enabledFilters = null;\n\n        /**\n         * The bounds object, this is used to calculate and store the bounds of the displayObject.\n         *\n         * @member {PIXI.Bounds}\n         * @protected\n         */\n        this._bounds = new Bounds();\n        this._boundsID = 0;\n        this._lastBoundsID = -1;\n        this._boundsRect = null;\n        this._localBoundsRect = null;\n\n        /**\n         * The original, cached mask of the object.\n         *\n         * @member {PIXI.Graphics|PIXI.Sprite|null}\n         * @protected\n         */\n        this._mask = null;\n\n        /**\n         * Fired when this DisplayObject is added to a Container.\n         *\n         * @event PIXI.DisplayObject#added\n         * @param {PIXI.Container} container - The container added to.\n         */\n\n        /**\n         * Fired when this DisplayObject is removed from a Container.\n         *\n         * @event PIXI.DisplayObject#removed\n         * @param {PIXI.Container} container - The container removed from.\n         */\n\n        /**\n         * If the object has been destroyed via destroy(). If true, it should not be used.\n         *\n         * @member {boolean}\n         * @protected\n         */\n        this._destroyed = false;\n\n        /**\n         * used to fast check if a sprite is.. a sprite!\n         * @member {boolean}\n         */\n        this.isSprite = false;\n\n        /**\n         * Does any other displayObject use this object as a mask?\n         * @member {boolean}\n         */\n        this.isMask = false;\n    }\n\n    /**\n     * @protected\n     * @member {PIXI.DisplayObject}\n     */\n    get _tempDisplayObjectParent()\n    {\n        if (this.tempDisplayObjectParent === null)\n        {\n            this.tempDisplayObjectParent = new DisplayObject();\n        }\n\n        return this.tempDisplayObjectParent;\n    }\n\n    /**\n     * Updates the object transform for rendering.\n     *\n     * TODO - Optimization pass!\n     */\n    updateTransform()\n    {\n        this._boundsID++;\n\n        this.transform.updateTransform(this.parent.transform);\n        // multiply the alphas..\n        this.worldAlpha = this.alpha * this.parent.worldAlpha;\n    }\n\n    /**\n     * Recalculates the bounds of the display object.\n     *\n     * Does nothing by default and can be overwritten in a parent class.\n     */\n    calculateBounds()\n    {\n        // OVERWRITE;\n    }\n\n    /**\n     * Recursively updates transform of all objects from the root to this one\n     * internal function for toLocal()\n     */\n    _recursivePostUpdateTransform()\n    {\n        if (this.parent)\n        {\n            this.parent._recursivePostUpdateTransform();\n            this.transform.updateTransform(this.parent.transform);\n        }\n        else\n        {\n            this.transform.updateTransform(this._tempDisplayObjectParent.transform);\n        }\n    }\n\n    /**\n     * Retrieves the bounds of the displayObject as a rectangle object.\n     *\n     * @param {boolean} [skipUpdate] - Setting to `true` will stop the transforms of the scene graph from\n     *  being updated. This means the calculation returned MAY be out of date BUT will give you a\n     *  nice performance boost.\n     * @param {PIXI.Rectangle} [rect] - Optional rectangle to store the result of the bounds calculation.\n     * @return {PIXI.Rectangle} The rectangular bounding area.\n     */\n    getBounds(skipUpdate, rect)\n    {\n        if (!skipUpdate)\n        {\n            if (!this.parent)\n            {\n                this.parent = this._tempDisplayObjectParent;\n                this.updateTransform();\n                this.parent = null;\n            }\n            else\n            {\n                this._recursivePostUpdateTransform();\n                this.updateTransform();\n            }\n        }\n\n        if (this._boundsID !== this._lastBoundsID)\n        {\n            this.calculateBounds();\n            this._lastBoundsID = this._boundsID;\n        }\n\n        if (!rect)\n        {\n            if (!this._boundsRect)\n            {\n                this._boundsRect = new Rectangle();\n            }\n\n            rect = this._boundsRect;\n        }\n\n        return this._bounds.getRectangle(rect);\n    }\n\n    /**\n     * Retrieves the local bounds of the displayObject as a rectangle object.\n     *\n     * @param {PIXI.Rectangle} [rect] - Optional rectangle to store the result of the bounds calculation.\n     * @return {PIXI.Rectangle} The rectangular bounding area.\n     */\n    getLocalBounds(rect)\n    {\n        const transformRef = this.transform;\n        const parentRef = this.parent;\n\n        this.parent = null;\n        this.transform = this._tempDisplayObjectParent.transform;\n\n        if (!rect)\n        {\n            if (!this._localBoundsRect)\n            {\n                this._localBoundsRect = new Rectangle();\n            }\n\n            rect = this._localBoundsRect;\n        }\n\n        const bounds = this.getBounds(false, rect);\n\n        this.parent = parentRef;\n        this.transform = transformRef;\n\n        return bounds;\n    }\n\n    /**\n     * Calculates the global position of the display object.\n     *\n     * @param {PIXI.IPoint} position - The world origin to calculate from.\n     * @param {PIXI.IPoint} [point] - A Point object in which to store the value, optional\n     *  (otherwise will create a new Point).\n     * @param {boolean} [skipUpdate=false] - Should we skip the update transform.\n     * @return {PIXI.IPoint} A point object representing the position of this object.\n     */\n    toGlobal(position, point, skipUpdate = false)\n    {\n        if (!skipUpdate)\n        {\n            this._recursivePostUpdateTransform();\n\n            // this parent check is for just in case the item is a root object.\n            // If it is we need to give it a temporary parent so that displayObjectUpdateTransform works correctly\n            // this is mainly to avoid a parent check in the main loop. Every little helps for performance :)\n            if (!this.parent)\n            {\n                this.parent = this._tempDisplayObjectParent;\n                this.displayObjectUpdateTransform();\n                this.parent = null;\n            }\n            else\n            {\n                this.displayObjectUpdateTransform();\n            }\n        }\n\n        // don't need to update the lot\n        return this.worldTransform.apply(position, point);\n    }\n\n    /**\n     * Calculates the local position of the display object relative to another point.\n     *\n     * @param {PIXI.IPoint} position - The world origin to calculate from.\n     * @param {PIXI.DisplayObject} [from] - The DisplayObject to calculate the global position from.\n     * @param {PIXI.IPoint} [point] - A Point object in which to store the value, optional\n     *  (otherwise will create a new Point).\n     * @param {boolean} [skipUpdate=false] - Should we skip the update transform\n     * @return {PIXI.IPoint} A point object representing the position of this object\n     */\n    toLocal(position, from, point, skipUpdate)\n    {\n        if (from)\n        {\n            position = from.toGlobal(position, point, skipUpdate);\n        }\n\n        if (!skipUpdate)\n        {\n            this._recursivePostUpdateTransform();\n\n            // this parent check is for just in case the item is a root object.\n            // If it is we need to give it a temporary parent so that displayObjectUpdateTransform works correctly\n            // this is mainly to avoid a parent check in the main loop. Every little helps for performance :)\n            if (!this.parent)\n            {\n                this.parent = this._tempDisplayObjectParent;\n                this.displayObjectUpdateTransform();\n                this.parent = null;\n            }\n            else\n            {\n                this.displayObjectUpdateTransform();\n            }\n        }\n\n        // simply apply the matrix..\n        return this.worldTransform.applyInverse(position, point);\n    }\n\n    /**\n     * Renders the object using the WebGL renderer.\n     *\n     * @param {PIXI.Renderer} renderer - The renderer.\n     */\n    render(renderer) // eslint-disable-line no-unused-vars\n    {\n        // OVERWRITE;\n    }\n\n    /**\n     * Set the parent Container of this DisplayObject.\n     *\n     * @param {PIXI.Container} container - The Container to add this DisplayObject to.\n     * @return {PIXI.Container} The Container that this DisplayObject was added to.\n     */\n    setParent(container)\n    {\n        if (!container || !container.addChild)\n        {\n            throw new Error('setParent: Argument must be a Container');\n        }\n\n        container.addChild(this);\n\n        return container;\n    }\n\n    /**\n     * Convenience function to set the position, scale, skew and pivot at once.\n     *\n     * @param {number} [x=0] - The X position\n     * @param {number} [y=0] - The Y position\n     * @param {number} [scaleX=1] - The X scale value\n     * @param {number} [scaleY=1] - The Y scale value\n     * @param {number} [rotation=0] - The rotation\n     * @param {number} [skewX=0] - The X skew value\n     * @param {number} [skewY=0] - The Y skew value\n     * @param {number} [pivotX=0] - The X pivot value\n     * @param {number} [pivotY=0] - The Y pivot value\n     * @return {PIXI.DisplayObject} The DisplayObject instance\n     */\n    setTransform(x = 0, y = 0, scaleX = 1, scaleY = 1, rotation = 0, skewX = 0, skewY = 0, pivotX = 0, pivotY = 0)\n    {\n        this.position.x = x;\n        this.position.y = y;\n        this.scale.x = !scaleX ? 1 : scaleX;\n        this.scale.y = !scaleY ? 1 : scaleY;\n        this.rotation = rotation;\n        this.skew.x = skewX;\n        this.skew.y = skewY;\n        this.pivot.x = pivotX;\n        this.pivot.y = pivotY;\n\n        return this;\n    }\n\n    /**\n     * Base destroy method for generic display objects. This will automatically\n     * remove the display object from its parent Container as well as remove\n     * all current event listeners and internal references. Do not use a DisplayObject\n     * after calling `destroy()`.\n     *\n     */\n    destroy()\n    {\n        if (this.parent)\n        {\n            this.parent.removeChild(this);\n        }\n        this.removeAllListeners();\n        this.transform = null;\n\n        this.parent = null;\n        this._bounds = null;\n        this._currentBounds = null;\n        this._mask = null;\n\n        this.filters = null;\n        this.filterArea = null;\n        this.hitArea = null;\n\n        this.interactive = false;\n        this.interactiveChildren = false;\n\n        this._destroyed = true;\n    }\n\n    /**\n     * The position of the displayObject on the x axis relative to the local coordinates of the parent.\n     * An alias to position.x\n     *\n     * @member {number}\n     */\n    get x()\n    {\n        return this.position.x;\n    }\n\n    set x(value) // eslint-disable-line require-jsdoc\n    {\n        this.transform.position.x = value;\n    }\n\n    /**\n     * The position of the displayObject on the y axis relative to the local coordinates of the parent.\n     * An alias to position.y\n     *\n     * @member {number}\n     */\n    get y()\n    {\n        return this.position.y;\n    }\n\n    set y(value) // eslint-disable-line require-jsdoc\n    {\n        this.transform.position.y = value;\n    }\n\n    /**\n     * Current transform of the object based on world (parent) factors.\n     *\n     * @member {PIXI.Matrix}\n     * @readonly\n     */\n    get worldTransform()\n    {\n        return this.transform.worldTransform;\n    }\n\n    /**\n     * Current transform of the object based on local factors: position, scale, other stuff.\n     *\n     * @member {PIXI.Matrix}\n     * @readonly\n     */\n    get localTransform()\n    {\n        return this.transform.localTransform;\n    }\n\n    /**\n     * The coordinate of the object relative to the local coordinates of the parent.\n     * Assignment by value since pixi-v4.\n     *\n     * @member {PIXI.IPoint}\n     */\n    get position()\n    {\n        return this.transform.position;\n    }\n\n    set position(value) // eslint-disable-line require-jsdoc\n    {\n        this.transform.position.copyFrom(value);\n    }\n\n    /**\n     * The scale factor of the object.\n     * Assignment by value since pixi-v4.\n     *\n     * @member {PIXI.IPoint}\n     */\n    get scale()\n    {\n        return this.transform.scale;\n    }\n\n    set scale(value) // eslint-disable-line require-jsdoc\n    {\n        this.transform.scale.copyFrom(value);\n    }\n\n    /**\n     * The pivot point of the displayObject that it rotates around.\n     * Assignment by value since pixi-v4.\n     *\n     * @member {PIXI.IPoint}\n     */\n    get pivot()\n    {\n        return this.transform.pivot;\n    }\n\n    set pivot(value) // eslint-disable-line require-jsdoc\n    {\n        this.transform.pivot.copyFrom(value);\n    }\n\n    /**\n     * The skew factor for the object in radians.\n     * Assignment by value since pixi-v4.\n     *\n     * @member {PIXI.ObservablePoint}\n     */\n    get skew()\n    {\n        return this.transform.skew;\n    }\n\n    set skew(value) // eslint-disable-line require-jsdoc\n    {\n        this.transform.skew.copyFrom(value);\n    }\n\n    /**\n     * The rotation of the object in radians.\n     * 'rotation' and 'angle' have the same effect on a display object; rotation is in radians, angle is in degrees.\n     *\n     * @member {number}\n     */\n    get rotation()\n    {\n        return this.transform.rotation;\n    }\n\n    set rotation(value) // eslint-disable-line require-jsdoc\n    {\n        this.transform.rotation = value;\n    }\n\n    /**\n     * The angle of the object in degrees.\n     * 'rotation' and 'angle' have the same effect on a display object; rotation is in radians, angle is in degrees.\n     *\n     * @member {number}\n     */\n    get angle()\n    {\n        return this.transform.rotation * RAD_TO_DEG;\n    }\n\n    set angle(value) // eslint-disable-line require-jsdoc\n    {\n        this.transform.rotation = value * DEG_TO_RAD;\n    }\n\n    /**\n     * The zIndex of the displayObject.\n     * If a container has the sortableChildren property set to true, children will be automatically\n     * sorted by zIndex value; a higher value will mean it will be moved towards the end of the array,\n     * and thus rendered on top of other displayObjects within the same container.\n     *\n     * @member {number}\n     */\n    get zIndex()\n    {\n        return this._zIndex;\n    }\n\n    set zIndex(value) // eslint-disable-line require-jsdoc\n    {\n        this._zIndex = value;\n        if (this.parent)\n        {\n            this.parent.sortDirty = true;\n        }\n    }\n\n    /**\n     * Indicates if the object is globally visible.\n     *\n     * @member {boolean}\n     * @readonly\n     */\n    get worldVisible()\n    {\n        let item = this;\n\n        do\n        {\n            if (!item.visible)\n            {\n                return false;\n            }\n\n            item = item.parent;\n        } while (item);\n\n        return true;\n    }\n\n    /**\n     * Sets a mask for the displayObject. A mask is an object that limits the visibility of an\n     * object to the shape of the mask applied to it. In PixiJS a regular mask must be a\n     * {@link PIXI.Graphics} or a {@link PIXI.Sprite} object. This allows for much faster masking in canvas as it\n     * utilities shape clipping. To remove a mask, set this property to `null`.\n     *\n     * For sprite mask both alpha and red channel are used. Black mask is the same as transparent mask.\n     * @example\n     * const graphics = new PIXI.Graphics();\n     * graphics.beginFill(0xFF3300);\n     * graphics.drawRect(50, 250, 100, 100);\n     * graphics.endFill();\n     *\n     * const sprite = new PIXI.Sprite(texture);\n     * sprite.mask = graphics;\n     * @todo At the moment, PIXI.CanvasRenderer doesn't support PIXI.Sprite as mask.\n     *\n     * @member {PIXI.Container|PIXI.MaskData}\n     */\n    get mask()\n    {\n        return this._mask;\n    }\n\n    set mask(value) // eslint-disable-line require-jsdoc\n    {\n        if (this._mask)\n        {\n            const maskObject = this._mask.maskObject || this._mask;\n\n            maskObject.renderable = true;\n            maskObject.isMask = false;\n        }\n\n        this._mask = value;\n\n        if (this._mask)\n        {\n            const maskObject = this._mask.maskObject || this._mask;\n\n            maskObject.renderable = false;\n            maskObject.isMask = true;\n        }\n    }\n}\n\n/**\n * DisplayObject default updateTransform, does not update children of container.\n * Will crash if there's no parent element.\n *\n * @memberof PIXI.DisplayObject#\n * @function displayObjectUpdateTransform\n */\nDisplayObject.prototype.displayObjectUpdateTransform = DisplayObject.prototype.updateTransform;\n","import { settings } from '@pixi/settings';\nimport { removeItems } from '@pixi/utils';\nimport { DisplayObject } from './DisplayObject';\n\nfunction sortChildren(a, b)\n{\n    if (a.zIndex === b.zIndex)\n    {\n        return a._lastSortedIndex - b._lastSortedIndex;\n    }\n\n    return a.zIndex - b.zIndex;\n}\n\n/**\n * A Container represents a collection of display objects.\n *\n * It is the base class of all display objects that act as a container for other objects (like Sprites).\n *\n *```js\n * let container = new PIXI.Container();\n * container.addChild(sprite);\n * ```\n *\n * @class\n * @extends PIXI.DisplayObject\n * @memberof PIXI\n */\nexport class Container extends DisplayObject\n{\n    constructor()\n    {\n        super();\n\n        /**\n         * The array of children of this container.\n         *\n         * @member {PIXI.DisplayObject[]}\n         * @readonly\n         */\n        this.children = [];\n\n        /**\n         * If set to true, the container will sort its children by zIndex value\n         * when updateTransform() is called, or manually if sortChildren() is called.\n         *\n         * This actually changes the order of elements in the array, so should be treated\n         * as a basic solution that is not performant compared to other solutions,\n         * such as @link https://github.com/pixijs/pixi-display\n         *\n         * Also be aware of that this may not work nicely with the addChildAt() function,\n         * as the zIndex sorting may cause the child to automatically sorted to another position.\n         *\n         * @see PIXI.settings.SORTABLE_CHILDREN\n         *\n         * @member {boolean}\n         */\n        this.sortableChildren = settings.SORTABLE_CHILDREN;\n\n        /**\n         * Should children be sorted by zIndex at the next updateTransform call.\n         * Will get automatically set to true if a new child is added, or if a child's zIndex changes.\n         *\n         * @member {boolean}\n         */\n        this.sortDirty = false;\n\n        /**\n         * Fired when a DisplayObject is added to this Container.\n         *\n         * @event PIXI.Container#childAdded\n         * @param {PIXI.DisplayObject} child - The child added to the Container.\n         * @param {PIXI.Container} container - The container that added the child.\n         * @param {number} index - The children's index of the added child.\n         */\n\n        /**\n         * Fired when a DisplayObject is removed from this Container.\n         *\n         * @event PIXI.DisplayObject#removedFrom\n         * @param {PIXI.DisplayObject} child - The child removed from the Container.\n         * @param {PIXI.Container} container - The container that removed removed the child.\n         * @param {number} index - The former children's index of the removed child\n         */\n    }\n\n    /**\n     * Overridable method that can be used by Container subclasses whenever the children array is modified\n     *\n     * @protected\n     */\n    onChildrenChange()\n    {\n        /* empty */\n    }\n\n    /**\n     * Adds one or more children to the container.\n     *\n     * Multiple items can be added like so: `myContainer.addChild(thingOne, thingTwo, thingThree)`\n     *\n     * @param {...PIXI.DisplayObject} child - The DisplayObject(s) to add to the container\n     * @return {PIXI.DisplayObject} The first child that was added.\n     */\n    addChild(child)\n    {\n        const argumentsLength = arguments.length;\n\n        // if there is only one argument we can bypass looping through the them\n        if (argumentsLength > 1)\n        {\n            // loop through the arguments property and add all children\n            // use it the right way (.length and [i]) so that this function can still be optimized by JS runtimes\n            for (let i = 0; i < argumentsLength; i++)\n            {\n                this.addChild(arguments[i]);\n            }\n        }\n        else\n        {\n            // if the child has a parent then lets remove it as PixiJS objects can only exist in one place\n            if (child.parent)\n            {\n                child.parent.removeChild(child);\n            }\n\n            child.parent = this;\n            this.sortDirty = true;\n\n            // ensure child transform will be recalculated\n            child.transform._parentID = -1;\n\n            this.children.push(child);\n\n            // ensure bounds will be recalculated\n            this._boundsID++;\n\n            // TODO - lets either do all callbacks or all events.. not both!\n            this.onChildrenChange(this.children.length - 1);\n            this.emit('childAdded', child, this, this.children.length - 1);\n            child.emit('added', this);\n        }\n\n        return child;\n    }\n\n    /**\n     * Adds a child to the container at a specified index. If the index is out of bounds an error will be thrown\n     *\n     * @param {PIXI.DisplayObject} child - The child to add\n     * @param {number} index - The index to place the child in\n     * @return {PIXI.DisplayObject} The child that was added.\n     */\n    addChildAt(child, index)\n    {\n        if (index < 0 || index > this.children.length)\n        {\n            throw new Error(`${child}addChildAt: The index ${index} supplied is out of bounds ${this.children.length}`);\n        }\n\n        if (child.parent)\n        {\n            child.parent.removeChild(child);\n        }\n\n        child.parent = this;\n        this.sortDirty = true;\n\n        // ensure child transform will be recalculated\n        child.transform._parentID = -1;\n\n        this.children.splice(index, 0, child);\n\n        // ensure bounds will be recalculated\n        this._boundsID++;\n\n        // TODO - lets either do all callbacks or all events.. not both!\n        this.onChildrenChange(index);\n        child.emit('added', this);\n        this.emit('childAdded', child, this, index);\n\n        return child;\n    }\n\n    /**\n     * Swaps the position of 2 Display Objects within this container.\n     *\n     * @param {PIXI.DisplayObject} child - First display object to swap\n     * @param {PIXI.DisplayObject} child2 - Second display object to swap\n     */\n    swapChildren(child, child2)\n    {\n        if (child === child2)\n        {\n            return;\n        }\n\n        const index1 = this.getChildIndex(child);\n        const index2 = this.getChildIndex(child2);\n\n        this.children[index1] = child2;\n        this.children[index2] = child;\n        this.onChildrenChange(index1 < index2 ? index1 : index2);\n    }\n\n    /**\n     * Returns the index position of a child DisplayObject instance\n     *\n     * @param {PIXI.DisplayObject} child - The DisplayObject instance to identify\n     * @return {number} The index position of the child display object to identify\n     */\n    getChildIndex(child)\n    {\n        const index = this.children.indexOf(child);\n\n        if (index === -1)\n        {\n            throw new Error('The supplied DisplayObject must be a child of the caller');\n        }\n\n        return index;\n    }\n\n    /**\n     * Changes the position of an existing child in the display object container\n     *\n     * @param {PIXI.DisplayObject} child - The child DisplayObject instance for which you want to change the index number\n     * @param {number} index - The resulting index number for the child display object\n     */\n    setChildIndex(child, index)\n    {\n        if (index < 0 || index >= this.children.length)\n        {\n            throw new Error(`The index ${index} supplied is out of bounds ${this.children.length}`);\n        }\n\n        const currentIndex = this.getChildIndex(child);\n\n        removeItems(this.children, currentIndex, 1); // remove from old position\n        this.children.splice(index, 0, child); // add at new position\n\n        this.onChildrenChange(index);\n    }\n\n    /**\n     * Returns the child at the specified index\n     *\n     * @param {number} index - The index to get the child at\n     * @return {PIXI.DisplayObject} The child at the given index, if any.\n     */\n    getChildAt(index)\n    {\n        if (index < 0 || index >= this.children.length)\n        {\n            throw new Error(`getChildAt: Index (${index}) does not exist.`);\n        }\n\n        return this.children[index];\n    }\n\n    /**\n     * Removes one or more children from the container.\n     *\n     * @param {...PIXI.DisplayObject} child - The DisplayObject(s) to remove\n     * @return {PIXI.DisplayObject} The first child that was removed.\n     */\n    removeChild(child)\n    {\n        const argumentsLength = arguments.length;\n\n        // if there is only one argument we can bypass looping through the them\n        if (argumentsLength > 1)\n        {\n            // loop through the arguments property and add all children\n            // use it the right way (.length and [i]) so that this function can still be optimized by JS runtimes\n            for (let i = 0; i < argumentsLength; i++)\n            {\n                this.removeChild(arguments[i]);\n            }\n        }\n        else\n        {\n            const index = this.children.indexOf(child);\n\n            if (index === -1) return null;\n\n            child.parent = null;\n            // ensure child transform will be recalculated\n            child.transform._parentID = -1;\n            removeItems(this.children, index, 1);\n\n            // ensure bounds will be recalculated\n            this._boundsID++;\n\n            // TODO - lets either do all callbacks or all events.. not both!\n            this.onChildrenChange(index);\n            child.emit('removed', this);\n            this.emit('childRemoved', child, this, index);\n        }\n\n        return child;\n    }\n\n    /**\n     * Removes a child from the specified index position.\n     *\n     * @param {number} index - The index to get the child from\n     * @return {PIXI.DisplayObject} The child that was removed.\n     */\n    removeChildAt(index)\n    {\n        const child = this.getChildAt(index);\n\n        // ensure child transform will be recalculated..\n        child.parent = null;\n        child.transform._parentID = -1;\n        removeItems(this.children, index, 1);\n\n        // ensure bounds will be recalculated\n        this._boundsID++;\n\n        // TODO - lets either do all callbacks or all events.. not both!\n        this.onChildrenChange(index);\n        child.emit('removed', this);\n        this.emit('childRemoved', child, this, index);\n\n        return child;\n    }\n\n    /**\n     * Removes all children from this container that are within the begin and end indexes.\n     *\n     * @param {number} [beginIndex=0] - The beginning position.\n     * @param {number} [endIndex=this.children.length] - The ending position. Default value is size of the container.\n     * @returns {PIXI.DisplayObject[]} List of removed children\n     */\n    removeChildren(beginIndex = 0, endIndex)\n    {\n        const begin = beginIndex;\n        const end = typeof endIndex === 'number' ? endIndex : this.children.length;\n        const range = end - begin;\n        let removed;\n\n        if (range > 0 && range <= end)\n        {\n            removed = this.children.splice(begin, range);\n\n            for (let i = 0; i < removed.length; ++i)\n            {\n                removed[i].parent = null;\n                if (removed[i].transform)\n                {\n                    removed[i].transform._parentID = -1;\n                }\n            }\n\n            this._boundsID++;\n\n            this.onChildrenChange(beginIndex);\n\n            for (let i = 0; i < removed.length; ++i)\n            {\n                removed[i].emit('removed', this);\n                this.emit('childRemoved', removed[i], this, i);\n            }\n\n            return removed;\n        }\n        else if (range === 0 && this.children.length === 0)\n        {\n            return [];\n        }\n\n        throw new RangeError('removeChildren: numeric values are outside the acceptable range.');\n    }\n\n    /**\n     * Sorts children by zIndex. Previous order is mantained for 2 children with the same zIndex.\n     */\n    sortChildren()\n    {\n        let sortRequired = false;\n\n        for (let i = 0, j = this.children.length; i < j; ++i)\n        {\n            const child = this.children[i];\n\n            child._lastSortedIndex = i;\n\n            if (!sortRequired && child.zIndex !== 0)\n            {\n                sortRequired = true;\n            }\n        }\n\n        if (sortRequired && this.children.length > 1)\n        {\n            this.children.sort(sortChildren);\n        }\n\n        this.sortDirty = false;\n    }\n\n    /**\n     * Updates the transform on all children of this container for rendering\n     */\n    updateTransform()\n    {\n        if (this.sortableChildren && this.sortDirty)\n        {\n            this.sortChildren();\n        }\n\n        this._boundsID++;\n\n        this.transform.updateTransform(this.parent.transform);\n\n        // TODO: check render flags, how to process stuff here\n        this.worldAlpha = this.alpha * this.parent.worldAlpha;\n\n        for (let i = 0, j = this.children.length; i < j; ++i)\n        {\n            const child = this.children[i];\n\n            if (child.visible)\n            {\n                child.updateTransform();\n            }\n        }\n    }\n\n    /**\n     * Recalculates the bounds of the container.\n     *\n     */\n    calculateBounds()\n    {\n        this._bounds.clear();\n\n        this._calculateBounds();\n\n        for (let i = 0; i < this.children.length; i++)\n        {\n            const child = this.children[i];\n\n            if (!child.visible || !child.renderable)\n            {\n                continue;\n            }\n\n            child.calculateBounds();\n\n            // TODO: filter+mask, need to mask both somehow\n            if (child._mask)\n            {\n                const maskObject = child._mask.maskObject || child._mask;\n\n                maskObject.calculateBounds();\n                this._bounds.addBoundsMask(child._bounds, maskObject._bounds);\n            }\n            else if (child.filterArea)\n            {\n                this._bounds.addBoundsArea(child._bounds, child.filterArea);\n            }\n            else\n            {\n                this._bounds.addBounds(child._bounds);\n            }\n        }\n\n        this._lastBoundsID = this._boundsID;\n    }\n\n    /**\n     * Recalculates the bounds of the object. Override this to\n     * calculate the bounds of the specific object (not including children).\n     *\n     * @protected\n     */\n    _calculateBounds()\n    {\n        // FILL IN//\n    }\n\n    /**\n     * Renders the object using the WebGL renderer\n     *\n     * @param {PIXI.Renderer} renderer - The renderer\n     */\n    render(renderer)\n    {\n        // if the object is not visible or the alpha is 0 then no need to render this element\n        if (!this.visible || this.worldAlpha <= 0 || !this.renderable)\n        {\n            return;\n        }\n\n        // do a quick check to see if this element has a mask or a filter.\n        if (this._mask || (this.filters && this.filters.length))\n        {\n            this.renderAdvanced(renderer);\n        }\n        else\n        {\n            this._render(renderer);\n\n            // simple render children!\n            for (let i = 0, j = this.children.length; i < j; ++i)\n            {\n                this.children[i].render(renderer);\n            }\n        }\n    }\n\n    /**\n     * Render the object using the WebGL renderer and advanced features.\n     *\n     * @protected\n     * @param {PIXI.Renderer} renderer - The renderer\n     */\n    renderAdvanced(renderer)\n    {\n        renderer.batch.flush();\n\n        const filters = this.filters;\n        const mask = this._mask;\n\n        // push filter first as we need to ensure the stencil buffer is correct for any masking\n        if (filters)\n        {\n            if (!this._enabledFilters)\n            {\n                this._enabledFilters = [];\n            }\n\n            this._enabledFilters.length = 0;\n\n            for (let i = 0; i < filters.length; i++)\n            {\n                if (filters[i].enabled)\n                {\n                    this._enabledFilters.push(filters[i]);\n                }\n            }\n\n            if (this._enabledFilters.length)\n            {\n                renderer.filter.push(this, this._enabledFilters);\n            }\n        }\n\n        if (mask)\n        {\n            renderer.mask.push(this, this._mask);\n        }\n\n        // add this object to the batch, only rendered if it has a texture.\n        this._render(renderer);\n\n        // now loop through the children and make sure they get rendered\n        for (let i = 0, j = this.children.length; i < j; i++)\n        {\n            this.children[i].render(renderer);\n        }\n\n        renderer.batch.flush();\n\n        if (mask)\n        {\n            renderer.mask.pop(this, this._mask);\n        }\n\n        if (filters && this._enabledFilters && this._enabledFilters.length)\n        {\n            renderer.filter.pop();\n        }\n    }\n\n    /**\n     * To be overridden by the subclasses.\n     *\n     * @protected\n     * @param {PIXI.Renderer} renderer - The renderer\n     */\n    _render(renderer) // eslint-disable-line no-unused-vars\n    {\n        // this is where content itself gets rendered...\n    }\n\n    /**\n     * Removes all internal references and listeners as well as removes children from the display list.\n     * Do not use a Container after calling `destroy`.\n     *\n     * @param {object|boolean} [options] - Options parameter. A boolean will act as if all options\n     *  have been set to that value\n     * @param {boolean} [options.children=false] - if set to true, all the children will have their destroy\n     *  method called as well. 'options' will be passed on to those calls.\n     * @param {boolean} [options.texture=false] - Only used for child Sprites if options.children is set to true\n     *  Should it destroy the texture of the child sprite\n     * @param {boolean} [options.baseTexture=false] - Only used for child Sprites if options.children is set to true\n     *  Should it destroy the base texture of the child sprite\n     */\n    destroy(options)\n    {\n        super.destroy();\n\n        this.sortDirty = false;\n\n        const destroyChildren = typeof options === 'boolean' ? options : options && options.children;\n\n        const oldChildren = this.removeChildren(0, this.children.length);\n\n        if (destroyChildren)\n        {\n            for (let i = 0; i < oldChildren.length; ++i)\n            {\n                oldChildren[i].destroy(options);\n            }\n        }\n    }\n\n    /**\n     * The width of the Container, setting this will actually modify the scale to achieve the value set\n     *\n     * @member {number}\n     */\n    get width()\n    {\n        return this.scale.x * this.getLocalBounds().width;\n    }\n\n    set width(value) // eslint-disable-line require-jsdoc\n    {\n        const width = this.getLocalBounds().width;\n\n        if (width !== 0)\n        {\n            this.scale.x = value / width;\n        }\n        else\n        {\n            this.scale.x = 1;\n        }\n\n        this._width = value;\n    }\n\n    /**\n     * The height of the Container, setting this will actually modify the scale to achieve the value set\n     *\n     * @member {number}\n     */\n    get height()\n    {\n        return this.scale.y * this.getLocalBounds().height;\n    }\n\n    set height(value) // eslint-disable-line require-jsdoc\n    {\n        const height = this.getLocalBounds().height;\n\n        if (height !== 0)\n        {\n            this.scale.y = value / height;\n        }\n        else\n        {\n            this.scale.y = 1;\n        }\n\n        this._height = value;\n    }\n}\n\n// performance increase to avoid using call.. (10x faster)\nContainer.prototype.containerUpdateTransform = Container.prototype.updateTransform;\n"]},"metadata":{},"sourceType":"module"}