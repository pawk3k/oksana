{"ast":null,"code":"/*!\n * @pixi/spritesheet - v5.2.1\n * Compiled Tue, 28 Jan 2020 23:33:11 UTC\n *\n * @pixi/spritesheet is licensed under the MIT License.\n * http://www.opensource.org/licenses/mit-license\n */\nimport { Rectangle } from '@pixi/math';\nimport { Texture } from '@pixi/core';\nimport { getResolutionOfUrl, url } from '@pixi/utils';\nimport { LoaderResource } from '@pixi/loaders';\n/**\n * Utility class for maintaining reference to a collection\n * of Textures on a single Spritesheet.\n *\n * To access a sprite sheet from your code pass its JSON data file to Pixi's loader:\n *\n * ```js\n * PIXI.Loader.shared.add(\"images/spritesheet.json\").load(setup);\n *\n * function setup() {\n *   let sheet = PIXI.Loader.shared.resources[\"images/spritesheet.json\"].spritesheet;\n *   ...\n * }\n * ```\n * With the `sheet.textures` you can create Sprite objects,`sheet.animations` can be used to create an AnimatedSprite.\n *\n * Sprite sheets can be packed using tools like {@link https://codeandweb.com/texturepacker|TexturePacker},\n * {@link https://renderhjs.net/shoebox/|Shoebox} or {@link https://github.com/krzysztof-o/spritesheet.js|Spritesheet.js}.\n * Default anchor points (see {@link PIXI.Texture#defaultAnchor}) and grouping of animation sprites are currently only\n * supported by TexturePacker.\n *\n * @class\n * @memberof PIXI\n */\n\nvar Spritesheet = function Spritesheet(baseTexture, data, resolutionFilename) {\n  if (resolutionFilename === void 0) resolutionFilename = null;\n  /**\n   * Reference to ths source texture\n   * @type {PIXI.BaseTexture}\n   */\n\n  this.baseTexture = baseTexture;\n  /**\n   * A map containing all textures of the sprite sheet.\n   * Can be used to create a {@link PIXI.Sprite|Sprite}:\n   * ```js\n   * new PIXI.Sprite(sheet.textures[\"image.png\"]);\n   * ```\n   * @member {Object}\n   */\n\n  this.textures = {};\n  /**\n   * A map containing the textures for each animation.\n   * Can be used to create an {@link PIXI.AnimatedSprite|AnimatedSprite}:\n   * ```js\n   * new PIXI.AnimatedSprite(sheet.animations[\"anim_name\"])\n   * ```\n   * @member {Object}\n   */\n\n  this.animations = {};\n  /**\n   * Reference to the original JSON data.\n   * @type {Object}\n   */\n\n  this.data = data;\n  /**\n   * The resolution of the spritesheet.\n   * @type {number}\n   */\n\n  this.resolution = this._updateResolution(resolutionFilename || (this.baseTexture.resource ? this.baseTexture.resource.url : null));\n  /**\n   * Map of spritesheet frames.\n   * @type {Object}\n   * @private\n   */\n\n  this._frames = this.data.frames;\n  /**\n   * Collection of frame names.\n   * @type {string[]}\n   * @private\n   */\n\n  this._frameKeys = Object.keys(this._frames);\n  /**\n   * Current batch index being processed.\n   * @type {number}\n   * @private\n   */\n\n  this._batchIndex = 0;\n  /**\n   * Callback when parse is completed.\n   * @type {Function}\n   * @private\n   */\n\n  this._callback = null;\n};\n\nvar staticAccessors = {\n  BATCH_SIZE: {\n    configurable: true\n  }\n};\n/**\n * Generate the resolution from the filename or fallback\n * to the meta.scale field of the JSON data.\n *\n * @private\n * @param {string} resolutionFilename - The filename to use for resolving\n *    the default resolution.\n * @return {number} Resolution to use for spritesheet.\n */\n\nstaticAccessors.BATCH_SIZE.get = function () {\n  return 1000;\n};\n\nSpritesheet.prototype._updateResolution = function _updateResolution(resolutionFilename) {\n  var scale = this.data.meta.scale; // Use a defaultValue of `null` to check if a url-based resolution is set\n\n  var resolution = getResolutionOfUrl(resolutionFilename, null); // No resolution found via URL\n\n  if (resolution === null) {\n    // Use the scale value or default to 1\n    resolution = scale !== undefined ? parseFloat(scale) : 1;\n  } // For non-1 resolutions, update baseTexture\n\n\n  if (resolution !== 1) {\n    this.baseTexture.setResolution(resolution);\n  }\n\n  return resolution;\n};\n/**\n * Parser spritesheet from loaded data. This is done asynchronously\n * to prevent creating too many Texture within a single process.\n *\n * @param {Function} callback - Callback when complete returns\n *    a map of the Textures for this spritesheet.\n */\n\n\nSpritesheet.prototype.parse = function parse(callback) {\n  this._batchIndex = 0;\n  this._callback = callback;\n\n  if (this._frameKeys.length <= Spritesheet.BATCH_SIZE) {\n    this._processFrames(0);\n\n    this._processAnimations();\n\n    this._parseComplete();\n  } else {\n    this._nextBatch();\n  }\n};\n/**\n * Process a batch of frames\n *\n * @private\n * @param {number} initialFrameIndex - The index of frame to start.\n */\n\n\nSpritesheet.prototype._processFrames = function _processFrames(initialFrameIndex) {\n  var frameIndex = initialFrameIndex;\n  var maxFrames = Spritesheet.BATCH_SIZE;\n\n  while (frameIndex - initialFrameIndex < maxFrames && frameIndex < this._frameKeys.length) {\n    var i = this._frameKeys[frameIndex];\n    var data = this._frames[i];\n    var rect = data.frame;\n\n    if (rect) {\n      var frame = null;\n      var trim = null;\n      var sourceSize = data.trimmed !== false && data.sourceSize ? data.sourceSize : data.frame;\n      var orig = new Rectangle(0, 0, Math.floor(sourceSize.w) / this.resolution, Math.floor(sourceSize.h) / this.resolution);\n\n      if (data.rotated) {\n        frame = new Rectangle(Math.floor(rect.x) / this.resolution, Math.floor(rect.y) / this.resolution, Math.floor(rect.h) / this.resolution, Math.floor(rect.w) / this.resolution);\n      } else {\n        frame = new Rectangle(Math.floor(rect.x) / this.resolution, Math.floor(rect.y) / this.resolution, Math.floor(rect.w) / this.resolution, Math.floor(rect.h) / this.resolution);\n      } //  Check to see if the sprite is trimmed\n\n\n      if (data.trimmed !== false && data.spriteSourceSize) {\n        trim = new Rectangle(Math.floor(data.spriteSourceSize.x) / this.resolution, Math.floor(data.spriteSourceSize.y) / this.resolution, Math.floor(rect.w) / this.resolution, Math.floor(rect.h) / this.resolution);\n      }\n\n      this.textures[i] = new Texture(this.baseTexture, frame, orig, trim, data.rotated ? 2 : 0, data.anchor); // lets also add the frame to pixi's global cache for 'from' and 'fromLoader' functions\n\n      Texture.addToCache(this.textures[i], i);\n    }\n\n    frameIndex++;\n  }\n};\n/**\n * Parse animations config\n *\n * @private\n */\n\n\nSpritesheet.prototype._processAnimations = function _processAnimations() {\n  var animations = this.data.animations || {};\n\n  for (var animName in animations) {\n    this.animations[animName] = [];\n\n    for (var i = 0; i < animations[animName].length; i++) {\n      var frameName = animations[animName][i];\n      this.animations[animName].push(this.textures[frameName]);\n    }\n  }\n};\n/**\n * The parse has completed.\n *\n * @private\n */\n\n\nSpritesheet.prototype._parseComplete = function _parseComplete() {\n  var callback = this._callback;\n  this._callback = null;\n  this._batchIndex = 0;\n  callback.call(this, this.textures);\n};\n/**\n * Begin the next batch of textures.\n *\n * @private\n */\n\n\nSpritesheet.prototype._nextBatch = function _nextBatch() {\n  var this$1 = this;\n\n  this._processFrames(this._batchIndex * Spritesheet.BATCH_SIZE);\n\n  this._batchIndex++;\n  setTimeout(function () {\n    if (this$1._batchIndex * Spritesheet.BATCH_SIZE < this$1._frameKeys.length) {\n      this$1._nextBatch();\n    } else {\n      this$1._processAnimations();\n\n      this$1._parseComplete();\n    }\n  }, 0);\n};\n/**\n * Destroy Spritesheet and don't use after this.\n *\n * @param {boolean} [destroyBase=false] Whether to destroy the base texture as well\n */\n\n\nSpritesheet.prototype.destroy = function destroy(destroyBase) {\n  if (destroyBase === void 0) destroyBase = false;\n\n  for (var i in this.textures) {\n    this.textures[i].destroy();\n  }\n\n  this._frames = null;\n  this._frameKeys = null;\n  this.data = null;\n  this.textures = null;\n\n  if (destroyBase) {\n    this.baseTexture.destroy();\n  }\n\n  this.baseTexture = null;\n};\n\nObject.defineProperties(Spritesheet, staticAccessors);\n/**\n * {@link PIXI.Loader Loader} middleware for loading texture atlases that have been created with\n * TexturePacker or similar JSON-based spritesheet.\n *\n * This middleware automatically generates Texture resources.\n *\n * @class\n * @memberof PIXI\n * @implements PIXI.ILoaderPlugin\n */\n\nvar SpritesheetLoader = function SpritesheetLoader() {};\n\nSpritesheetLoader.use = function use(resource, next) {\n  var imageResourceName = resource.name + \"_image\"; // skip if no data, its not json, it isn't spritesheet data, or the image resource already exists\n\n  if (!resource.data || resource.type !== LoaderResource.TYPE.JSON || !resource.data.frames || this.resources[imageResourceName]) {\n    next();\n    return;\n  }\n\n  var loadOptions = {\n    crossOrigin: resource.crossOrigin,\n    metadata: resource.metadata.imageMetadata,\n    parentResource: resource\n  };\n  var resourcePath = SpritesheetLoader.getResourcePath(resource, this.baseUrl); // load the image for this sheet\n\n  this.add(imageResourceName, resourcePath, loadOptions, function onImageLoad(res) {\n    if (res.error) {\n      next(res.error);\n      return;\n    }\n\n    var spritesheet = new Spritesheet(res.texture.baseTexture, resource.data, resource.url);\n    spritesheet.parse(function () {\n      resource.spritesheet = spritesheet;\n      resource.textures = spritesheet.textures;\n      next();\n    });\n  });\n};\n/**\n * Get the spritesheets root path\n * @param {PIXI.LoaderResource} resource - Resource to check path\n * @param {string} baseUrl - Base root url\n */\n\n\nSpritesheetLoader.getResourcePath = function getResourcePath(resource, baseUrl) {\n  // Prepend url path unless the resource image is a data url\n  if (resource.isDataUrl) {\n    return resource.data.meta.image;\n  }\n\n  return url.resolve(resource.url.replace(baseUrl, ''), resource.data.meta.image);\n};\n\nexport { Spritesheet, SpritesheetLoader };","map":{"version":3,"sources":["../src/Spritesheet.js","../src/SpritesheetLoader.js"],"names":["let","const","this"],"mappings":"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","sourcesContent":["import { Rectangle } from '@pixi/math';\nimport { Texture } from '@pixi/core';\nimport { getResolutionOfUrl } from '@pixi/utils';\n\n/**\n * Utility class for maintaining reference to a collection\n * of Textures on a single Spritesheet.\n *\n * To access a sprite sheet from your code pass its JSON data file to Pixi's loader:\n *\n * ```js\n * PIXI.Loader.shared.add(\"images/spritesheet.json\").load(setup);\n *\n * function setup() {\n *   let sheet = PIXI.Loader.shared.resources[\"images/spritesheet.json\"].spritesheet;\n *   ...\n * }\n * ```\n * With the `sheet.textures` you can create Sprite objects,`sheet.animations` can be used to create an AnimatedSprite.\n *\n * Sprite sheets can be packed using tools like {@link https://codeandweb.com/texturepacker|TexturePacker},\n * {@link https://renderhjs.net/shoebox/|Shoebox} or {@link https://github.com/krzysztof-o/spritesheet.js|Spritesheet.js}.\n * Default anchor points (see {@link PIXI.Texture#defaultAnchor}) and grouping of animation sprites are currently only\n * supported by TexturePacker.\n *\n * @class\n * @memberof PIXI\n */\nexport class Spritesheet\n{\n    /**\n     * The maximum number of Textures to build per process.\n     *\n     * @type {number}\n     * @default 1000\n     */\n    static get BATCH_SIZE()\n    {\n        return 1000;\n    }\n\n    /**\n     * @param {PIXI.BaseTexture} baseTexture Reference to the source BaseTexture object.\n     * @param {Object} data - Spritesheet image data.\n     * @param {string} [resolutionFilename] - The filename to consider when determining\n     *        the resolution of the spritesheet. If not provided, the imageUrl will\n     *        be used on the BaseTexture.\n     */\n    constructor(baseTexture, data, resolutionFilename = null)\n    {\n        /**\n         * Reference to ths source texture\n         * @type {PIXI.BaseTexture}\n         */\n        this.baseTexture = baseTexture;\n\n        /**\n         * A map containing all textures of the sprite sheet.\n         * Can be used to create a {@link PIXI.Sprite|Sprite}:\n         * ```js\n         * new PIXI.Sprite(sheet.textures[\"image.png\"]);\n         * ```\n         * @member {Object}\n         */\n        this.textures = {};\n\n        /**\n         * A map containing the textures for each animation.\n         * Can be used to create an {@link PIXI.AnimatedSprite|AnimatedSprite}:\n         * ```js\n         * new PIXI.AnimatedSprite(sheet.animations[\"anim_name\"])\n         * ```\n         * @member {Object}\n         */\n        this.animations = {};\n\n        /**\n         * Reference to the original JSON data.\n         * @type {Object}\n         */\n        this.data = data;\n\n        /**\n         * The resolution of the spritesheet.\n         * @type {number}\n         */\n        this.resolution = this._updateResolution(\n            resolutionFilename\n            || (this.baseTexture.resource ? this.baseTexture.resource.url : null)\n        );\n\n        /**\n         * Map of spritesheet frames.\n         * @type {Object}\n         * @private\n         */\n        this._frames = this.data.frames;\n\n        /**\n         * Collection of frame names.\n         * @type {string[]}\n         * @private\n         */\n        this._frameKeys = Object.keys(this._frames);\n\n        /**\n         * Current batch index being processed.\n         * @type {number}\n         * @private\n         */\n        this._batchIndex = 0;\n\n        /**\n         * Callback when parse is completed.\n         * @type {Function}\n         * @private\n         */\n        this._callback = null;\n    }\n\n    /**\n     * Generate the resolution from the filename or fallback\n     * to the meta.scale field of the JSON data.\n     *\n     * @private\n     * @param {string} resolutionFilename - The filename to use for resolving\n     *        the default resolution.\n     * @return {number} Resolution to use for spritesheet.\n     */\n    _updateResolution(resolutionFilename)\n    {\n        const scale = this.data.meta.scale;\n\n        // Use a defaultValue of `null` to check if a url-based resolution is set\n        let resolution = getResolutionOfUrl(resolutionFilename, null);\n\n        // No resolution found via URL\n        if (resolution === null)\n        {\n            // Use the scale value or default to 1\n            resolution = scale !== undefined ? parseFloat(scale) : 1;\n        }\n\n        // For non-1 resolutions, update baseTexture\n        if (resolution !== 1)\n        {\n            this.baseTexture.setResolution(resolution);\n        }\n\n        return resolution;\n    }\n\n    /**\n     * Parser spritesheet from loaded data. This is done asynchronously\n     * to prevent creating too many Texture within a single process.\n     *\n     * @param {Function} callback - Callback when complete returns\n     *        a map of the Textures for this spritesheet.\n     */\n    parse(callback)\n    {\n        this._batchIndex = 0;\n        this._callback = callback;\n\n        if (this._frameKeys.length <= Spritesheet.BATCH_SIZE)\n        {\n            this._processFrames(0);\n            this._processAnimations();\n            this._parseComplete();\n        }\n        else\n        {\n            this._nextBatch();\n        }\n    }\n\n    /**\n     * Process a batch of frames\n     *\n     * @private\n     * @param {number} initialFrameIndex - The index of frame to start.\n     */\n    _processFrames(initialFrameIndex)\n    {\n        let frameIndex = initialFrameIndex;\n        const maxFrames = Spritesheet.BATCH_SIZE;\n\n        while (frameIndex - initialFrameIndex < maxFrames && frameIndex < this._frameKeys.length)\n        {\n            const i = this._frameKeys[frameIndex];\n            const data = this._frames[i];\n            const rect = data.frame;\n\n            if (rect)\n            {\n                let frame = null;\n                let trim = null;\n                const sourceSize = data.trimmed !== false && data.sourceSize\n                    ? data.sourceSize : data.frame;\n\n                const orig = new Rectangle(\n                    0,\n                    0,\n                    Math.floor(sourceSize.w) / this.resolution,\n                    Math.floor(sourceSize.h) / this.resolution\n                );\n\n                if (data.rotated)\n                {\n                    frame = new Rectangle(\n                        Math.floor(rect.x) / this.resolution,\n                        Math.floor(rect.y) / this.resolution,\n                        Math.floor(rect.h) / this.resolution,\n                        Math.floor(rect.w) / this.resolution\n                    );\n                }\n                else\n                {\n                    frame = new Rectangle(\n                        Math.floor(rect.x) / this.resolution,\n                        Math.floor(rect.y) / this.resolution,\n                        Math.floor(rect.w) / this.resolution,\n                        Math.floor(rect.h) / this.resolution\n                    );\n                }\n\n                //  Check to see if the sprite is trimmed\n                if (data.trimmed !== false && data.spriteSourceSize)\n                {\n                    trim = new Rectangle(\n                        Math.floor(data.spriteSourceSize.x) / this.resolution,\n                        Math.floor(data.spriteSourceSize.y) / this.resolution,\n                        Math.floor(rect.w) / this.resolution,\n                        Math.floor(rect.h) / this.resolution\n                    );\n                }\n\n                this.textures[i] = new Texture(\n                    this.baseTexture,\n                    frame,\n                    orig,\n                    trim,\n                    data.rotated ? 2 : 0,\n                    data.anchor\n                );\n\n                // lets also add the frame to pixi's global cache for 'from' and 'fromLoader' functions\n                Texture.addToCache(this.textures[i], i);\n            }\n\n            frameIndex++;\n        }\n    }\n\n    /**\n     * Parse animations config\n     *\n     * @private\n     */\n    _processAnimations()\n    {\n        const animations = this.data.animations || {};\n\n        for (const animName in animations)\n        {\n            this.animations[animName] = [];\n            for (let i = 0; i < animations[animName].length; i++)\n            {\n                const frameName = animations[animName][i];\n\n                this.animations[animName].push(this.textures[frameName]);\n            }\n        }\n    }\n\n    /**\n     * The parse has completed.\n     *\n     * @private\n     */\n    _parseComplete()\n    {\n        const callback = this._callback;\n\n        this._callback = null;\n        this._batchIndex = 0;\n        callback.call(this, this.textures);\n    }\n\n    /**\n     * Begin the next batch of textures.\n     *\n     * @private\n     */\n    _nextBatch()\n    {\n        this._processFrames(this._batchIndex * Spritesheet.BATCH_SIZE);\n        this._batchIndex++;\n        setTimeout(() =>\n        {\n            if (this._batchIndex * Spritesheet.BATCH_SIZE < this._frameKeys.length)\n            {\n                this._nextBatch();\n            }\n            else\n            {\n                this._processAnimations();\n                this._parseComplete();\n            }\n        }, 0);\n    }\n\n    /**\n     * Destroy Spritesheet and don't use after this.\n     *\n     * @param {boolean} [destroyBase=false] Whether to destroy the base texture as well\n     */\n    destroy(destroyBase = false)\n    {\n        for (const i in this.textures)\n        {\n            this.textures[i].destroy();\n        }\n        this._frames = null;\n        this._frameKeys = null;\n        this.data = null;\n        this.textures = null;\n        if (destroyBase)\n        {\n            this.baseTexture.destroy();\n        }\n        this.baseTexture = null;\n    }\n}\n","import { url } from '@pixi/utils';\nimport { LoaderResource } from '@pixi/loaders';\nimport { Spritesheet } from './Spritesheet';\n\n/**\n * {@link PIXI.Loader Loader} middleware for loading texture atlases that have been created with\n * TexturePacker or similar JSON-based spritesheet.\n *\n * This middleware automatically generates Texture resources.\n *\n * @class\n * @memberof PIXI\n * @implements PIXI.ILoaderPlugin\n */\nexport class SpritesheetLoader\n{\n    /**\n     * Called after a resource is loaded.\n     * @see PIXI.Loader.loaderMiddleware\n     * @param {PIXI.LoaderResource} resource\n     * @param {function} next\n     */\n    static use(resource, next)\n    {\n        const imageResourceName = `${resource.name}_image`;\n\n        // skip if no data, its not json, it isn't spritesheet data, or the image resource already exists\n        if (!resource.data\n            || resource.type !== LoaderResource.TYPE.JSON\n            || !resource.data.frames\n            || this.resources[imageResourceName]\n        )\n        {\n            next();\n\n            return;\n        }\n\n        const loadOptions = {\n            crossOrigin: resource.crossOrigin,\n            metadata: resource.metadata.imageMetadata,\n            parentResource: resource,\n        };\n\n        const resourcePath = SpritesheetLoader.getResourcePath(resource, this.baseUrl);\n\n        // load the image for this sheet\n        this.add(imageResourceName, resourcePath, loadOptions, function onImageLoad(res)\n        {\n            if (res.error)\n            {\n                next(res.error);\n\n                return;\n            }\n\n            const spritesheet = new Spritesheet(\n                res.texture.baseTexture,\n                resource.data,\n                resource.url\n            );\n\n            spritesheet.parse(() =>\n            {\n                resource.spritesheet = spritesheet;\n                resource.textures = spritesheet.textures;\n                next();\n            });\n        });\n    }\n\n    /**\n     * Get the spritesheets root path\n     * @param {PIXI.LoaderResource} resource - Resource to check path\n     * @param {string} baseUrl - Base root url\n     */\n    static getResourcePath(resource, baseUrl)\n    {\n        // Prepend url path unless the resource image is a data url\n        if (resource.isDataUrl)\n        {\n            return resource.data.meta.image;\n        }\n\n        return url.resolve(resource.url.replace(baseUrl, ''), resource.data.meta.image);\n    }\n}\n"]},"metadata":{},"sourceType":"module"}