{"ast":null,"code":"/*!\n * @pixi/filter-displacement - v5.2.1\n * Compiled Tue, 28 Jan 2020 23:33:11 UTC\n *\n * @pixi/filter-displacement is licensed under the MIT License.\n * http://www.opensource.org/licenses/mit-license\n */\nimport { Filter } from '@pixi/core';\nimport { Matrix, Point } from '@pixi/math';\nvar vertex = \"attribute vec2 aVertexPosition;\\n\\nuniform mat3 projectionMatrix;\\nuniform mat3 filterMatrix;\\n\\nvarying vec2 vTextureCoord;\\nvarying vec2 vFilterCoord;\\n\\nuniform vec4 inputSize;\\nuniform vec4 outputFrame;\\n\\nvec4 filterVertexPosition( void )\\n{\\n    vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;\\n\\n    return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\\n}\\n\\nvec2 filterTextureCoord( void )\\n{\\n    return aVertexPosition * (outputFrame.zw * inputSize.zw);\\n}\\n\\nvoid main(void)\\n{\\n\\tgl_Position = filterVertexPosition();\\n\\tvTextureCoord = filterTextureCoord();\\n\\tvFilterCoord = ( filterMatrix * vec3( vTextureCoord, 1.0)  ).xy;\\n}\\n\";\nvar fragment = \"varying vec2 vFilterCoord;\\nvarying vec2 vTextureCoord;\\n\\nuniform vec2 scale;\\nuniform mat2 rotation;\\nuniform sampler2D uSampler;\\nuniform sampler2D mapSampler;\\n\\nuniform highp vec4 inputSize;\\nuniform vec4 inputClamp;\\n\\nvoid main(void)\\n{\\n  vec4 map =  texture2D(mapSampler, vFilterCoord);\\n\\n  map -= 0.5;\\n  map.xy = scale * inputSize.zw * (rotation * map.xy);\\n\\n  gl_FragColor = texture2D(uSampler, clamp(vec2(vTextureCoord.x + map.x, vTextureCoord.y + map.y), inputClamp.xy, inputClamp.zw));\\n}\\n\";\n/**\n * The DisplacementFilter class uses the pixel values from the specified texture\n * (called the displacement map) to perform a displacement of an object.\n *\n * You can use this filter to apply all manor of crazy warping effects.\n * Currently the `r` property of the texture is used to offset the `x`\n * and the `g` property of the texture is used to offset the `y`.\n *\n * The way it works is it uses the values of the displacement map to look up the\n * correct pixels to output. This means it's not technically moving the original.\n * Instead, it's starting at the output and asking \"which pixel from the original goes here\".\n * For example, if a displacement map pixel has `red = 1` and the filter scale is `20`,\n * this filter will output the pixel approximately 20 pixels to the right of the original.\n *\n * @class\n * @extends PIXI.Filter\n * @memberof PIXI.filters\n */\n\nvar DisplacementFilter =\n/*@__PURE__*/\nfunction (Filter) {\n  function DisplacementFilter(sprite, scale) {\n    var maskMatrix = new Matrix();\n    sprite.renderable = false;\n    Filter.call(this, vertex, fragment, {\n      mapSampler: sprite._texture,\n      filterMatrix: maskMatrix,\n      scale: {\n        x: 1,\n        y: 1\n      },\n      rotation: new Float32Array([1, 0, 0, 1])\n    });\n    this.maskSprite = sprite;\n    this.maskMatrix = maskMatrix;\n\n    if (scale === null || scale === undefined) {\n      scale = 20;\n    }\n    /**\n     * scaleX, scaleY for displacements\n     * @member {PIXI.Point}\n     */\n\n\n    this.scale = new Point(scale, scale);\n  }\n\n  if (Filter) DisplacementFilter.__proto__ = Filter;\n  DisplacementFilter.prototype = Object.create(Filter && Filter.prototype);\n  DisplacementFilter.prototype.constructor = DisplacementFilter;\n  var prototypeAccessors = {\n    map: {\n      configurable: true\n    }\n  };\n  /**\n   * Applies the filter.\n   *\n   * @param {PIXI.systems.FilterSystem} filterManager - The manager.\n   * @param {PIXI.RenderTexture} input - The input target.\n   * @param {PIXI.RenderTexture} output - The output target.\n   * @param {boolean} clear - Should the output be cleared before rendering to it.\n   */\n\n  DisplacementFilter.prototype.apply = function apply(filterManager, input, output, clear) {\n    // fill maskMatrix with _normalized sprite texture coords_\n    this.uniforms.filterMatrix = filterManager.calculateSpriteMatrix(this.maskMatrix, this.maskSprite);\n    this.uniforms.scale.x = this.scale.x;\n    this.uniforms.scale.y = this.scale.y; // Extract rotation from world transform\n\n    var wt = this.maskSprite.transform.worldTransform;\n    var lenX = Math.sqrt(wt.a * wt.a + wt.b * wt.b);\n    var lenY = Math.sqrt(wt.c * wt.c + wt.d * wt.d);\n\n    if (lenX !== 0 && lenY !== 0) {\n      this.uniforms.rotation[0] = wt.a / lenX;\n      this.uniforms.rotation[1] = wt.b / lenX;\n      this.uniforms.rotation[2] = wt.c / lenY;\n      this.uniforms.rotation[3] = wt.d / lenY;\n    } // draw the filter...\n\n\n    filterManager.applyFilter(this, input, output, clear);\n  };\n  /**\n   * The texture used for the displacement map. Must be power of 2 sized texture.\n   *\n   * @member {PIXI.Texture}\n   */\n\n\n  prototypeAccessors.map.get = function () {\n    return this.uniforms.mapSampler;\n  };\n\n  prototypeAccessors.map.set = function (value) // eslint-disable-line require-jsdoc\n  {\n    this.uniforms.mapSampler = value;\n  };\n\n  Object.defineProperties(DisplacementFilter.prototype, prototypeAccessors);\n  return DisplacementFilter;\n}(Filter);\n\nexport { DisplacementFilter };","map":{"version":3,"sources":["../src/DisplacementFilter.js"],"names":["const","super"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAuBA,IAAa,kBAAkB;AAAA;AAAA,UAAA,MAAA,EAAA;AAM3B,WAAA,kBAAA,CAAY,MAAZ,EAAoB,KAApB,EACA;AACIA,QAAM,UAAU,GAAG,IAAI,MAAJ,EAAnBA;AAEA,IAAA,MAAM,CAAC,UAAP,GAAoB,KAApB;AAEAC,IAAAA,MAAAA,CAAAA,IAAAA,CAAK,IAALA,EAAM,MAANA,EAAc,QAAdA,EAAwB;AACpB,MAAA,UAAU,EAAE,MAAM,CAAC,QADC;AAEpB,MAAA,YAAY,EAAE,UAFM;AAGpB,MAAA,KAAK,EAAE;AAAE,QAAA,CAAC,EAAE,CAAL;AAAQ,QAAA,CAAC,EAAE;AAAX,OAHa;AAIpB,MAAA,QAAQ,EAAE,IAAI,YAAJ,CAAiB,CAAC,CAAD,EAAI,CAAJ,EAAO,CAAP,EAAU,CAAV,CAAjB;AAJU,KAAxBA;AAOA,SAAK,UAAL,GAAkB,MAAlB;AACA,SAAK,UAAL,GAAkB,UAAlB;;AAEA,QAAI,KAAK,KAAK,IAAV,IAAkB,KAAK,KAAK,SAAhC,EACA;AACI,MAAA,KAAK,GAAG,EAAR;AACH;;;;;;;AAMD,SAAK,KAAL,GAAa,IAAI,KAAJ,CAAU,KAAV,EAAiB,KAAjB,CAAb;;;;;;;;oBACH;;;;;;;;;;;;+BAUD,K,GAAA,SAAA,KAAA,CAAM,aAAN,EAAqB,KAArB,EAA4B,MAA5B,EAAoC,KAApC,EACA;;AAEI,SAAK,QAAL,CAAc,YAAd,GAA6B,aAAa,CAAC,qBAAd,CAAoC,KAAK,UAAzC,EAAqD,KAAK,UAA1D,CAA7B;AACA,SAAK,QAAL,CAAc,KAAd,CAAoB,CAApB,GAAwB,KAAK,KAAL,CAAW,CAAnC;AACA,SAAK,QAAL,CAAc,KAAd,CAAoB,CAApB,GAAwB,KAAK,KAAL,CAAW,CAAnC,CAJJ,C;;AAOID,QAAM,EAAE,GAAG,KAAK,UAAL,CAAgB,SAAhB,CAA0B,cAArCA;AACAA,QAAM,IAAI,GAAG,IAAI,CAAC,IAAL,CAAW,EAAE,CAAC,CAAH,GAAO,EAAE,CAAC,CAAX,GAAiB,EAAE,CAAC,CAAH,GAAO,EAAE,CAAC,CAArC,CAAbA;AACAA,QAAM,IAAI,GAAG,IAAI,CAAC,IAAL,CAAW,EAAE,CAAC,CAAH,GAAO,EAAE,CAAC,CAAX,GAAiB,EAAE,CAAC,CAAH,GAAO,EAAE,CAAC,CAArC,CAAbA;;AAEA,QAAI,IAAI,KAAK,CAAT,IAAc,IAAI,KAAK,CAA3B,EACA;AACI,WAAK,QAAL,CAAc,QAAd,CAAuB,CAAvB,IAA4B,EAAE,CAAC,CAAH,GAAO,IAAnC;AACA,WAAK,QAAL,CAAc,QAAd,CAAuB,CAAvB,IAA4B,EAAE,CAAC,CAAH,GAAO,IAAnC;AACA,WAAK,QAAL,CAAc,QAAd,CAAuB,CAAvB,IAA4B,EAAE,CAAC,CAAH,GAAO,IAAnC;AACA,WAAK,QAAL,CAAc,QAAd,CAAuB,CAAvB,IAA4B,EAAE,CAAC,CAAH,GAAO,IAAnC;AACH,KAjBL,C;;;AAoBI,IAAA,aAAa,CAAC,WAAd,CAA0B,IAA1B,EAAgC,KAAhC,EAAuC,MAAvC,EAA+C,KAA/C;AACH,G;;;;;;;;AAOD,EAAA,kBAAA,CAAI,GAAJ,CAAI,GAAJ,GAAI,YACJ;AACI,WAAO,KAAK,QAAL,CAAc,UAArB;AACH,GAHD;;AAKA,EAAA,kBAAA,CAAI,GAAJ,CAAI,GAAJ,GAAI,UAAI,KAAJ,EAAS;AACb;AACI,SAAK,QAAL,CAAc,UAAd,GAA2B,KAA3B;AACH,GAHD;;;;CA5E2B,CAAS,MAAT,CAA/B","sourcesContent":["import { Filter } from '@pixi/core';\nimport { Matrix, Point } from '@pixi/math';\nimport vertex from './displacement.vert';\nimport fragment from './displacement.frag';\n\n/**\n * The DisplacementFilter class uses the pixel values from the specified texture\n * (called the displacement map) to perform a displacement of an object.\n *\n * You can use this filter to apply all manor of crazy warping effects.\n * Currently the `r` property of the texture is used to offset the `x`\n * and the `g` property of the texture is used to offset the `y`.\n *\n * The way it works is it uses the values of the displacement map to look up the\n * correct pixels to output. This means it's not technically moving the original.\n * Instead, it's starting at the output and asking \"which pixel from the original goes here\".\n * For example, if a displacement map pixel has `red = 1` and the filter scale is `20`,\n * this filter will output the pixel approximately 20 pixels to the right of the original.\n *\n * @class\n * @extends PIXI.Filter\n * @memberof PIXI.filters\n */\nexport class DisplacementFilter extends Filter\n{\n    /**\n     * @param {PIXI.Sprite} sprite - The sprite used for the displacement map. (make sure its added to the scene!)\n     * @param {number} [scale] - The scale of the displacement\n     */\n    constructor(sprite, scale)\n    {\n        const maskMatrix = new Matrix();\n\n        sprite.renderable = false;\n\n        super(vertex, fragment, {\n            mapSampler: sprite._texture,\n            filterMatrix: maskMatrix,\n            scale: { x: 1, y: 1 },\n            rotation: new Float32Array([1, 0, 0, 1]),\n        });\n\n        this.maskSprite = sprite;\n        this.maskMatrix = maskMatrix;\n\n        if (scale === null || scale === undefined)\n        {\n            scale = 20;\n        }\n\n        /**\n         * scaleX, scaleY for displacements\n         * @member {PIXI.Point}\n         */\n        this.scale = new Point(scale, scale);\n    }\n\n    /**\n     * Applies the filter.\n     *\n     * @param {PIXI.systems.FilterSystem} filterManager - The manager.\n     * @param {PIXI.RenderTexture} input - The input target.\n     * @param {PIXI.RenderTexture} output - The output target.\n     * @param {boolean} clear - Should the output be cleared before rendering to it.\n     */\n    apply(filterManager, input, output, clear)\n    {\n        // fill maskMatrix with _normalized sprite texture coords_\n        this.uniforms.filterMatrix = filterManager.calculateSpriteMatrix(this.maskMatrix, this.maskSprite);\n        this.uniforms.scale.x = this.scale.x;\n        this.uniforms.scale.y = this.scale.y;\n\n        // Extract rotation from world transform\n        const wt = this.maskSprite.transform.worldTransform;\n        const lenX = Math.sqrt((wt.a * wt.a) + (wt.b * wt.b));\n        const lenY = Math.sqrt((wt.c * wt.c) + (wt.d * wt.d));\n\n        if (lenX !== 0 && lenY !== 0)\n        {\n            this.uniforms.rotation[0] = wt.a / lenX;\n            this.uniforms.rotation[1] = wt.b / lenX;\n            this.uniforms.rotation[2] = wt.c / lenY;\n            this.uniforms.rotation[3] = wt.d / lenY;\n        }\n\n        // draw the filter...\n        filterManager.applyFilter(this, input, output, clear);\n    }\n\n    /**\n     * The texture used for the displacement map. Must be power of 2 sized texture.\n     *\n     * @member {PIXI.Texture}\n     */\n    get map()\n    {\n        return this.uniforms.mapSampler;\n    }\n\n    set map(value) // eslint-disable-line require-jsdoc\n    {\n        this.uniforms.mapSampler = value;\n    }\n}\n"]},"metadata":{},"sourceType":"module"}