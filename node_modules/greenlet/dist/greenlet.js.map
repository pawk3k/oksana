{"version":3,"file":"greenlet.js","sources":["../greenlet.js"],"sourcesContent":["/** Move an async function into its own thread.\n *  @param {Function} asyncFunction  An (async) function to run in a Worker.\n *  @public\n */\nexport default function greenlet(asyncFunction) {\n\t// A simple counter is used to generate worker-global unique ID's for RPC:\n\tlet currentId = 0;\n\n\t// Outward-facing promises store their \"controllers\" (`[request, reject]`) here:\n\tconst promises = {};\n\n\t// Use a data URI for the worker's src. It inlines the target function and an RPC handler:\n\tconst script = '$$='+asyncFunction+';onmessage='+(e => {\n\t\t/* global $$ */\n\n\t\t// Invoking within then() captures exceptions in the supplied async function as rejections\n\t\tPromise.resolve(e.data[1]).then(\n\t\t\tv => $$.apply($$, v)\n\t\t).then(\n\t\t\t// success handler - callback(id, SUCCESS(0), result)\n\t\t\t// if `d` is transferable transfer zero-copy\n\t\t\td => {\n\t\t\t\tpostMessage([e.data[0], 0, d], [d].filter(x => (\n\t\t\t\t\t(x instanceof ArrayBuffer) ||\n\t\t\t\t\t(x instanceof MessagePort) ||\n\t\t\t\t\t(self.ImageBitmap && x instanceof ImageBitmap)\n\t\t\t\t)));\n\t\t\t},\n\t\t\t// error handler - callback(id, ERROR(1), error)\n\t\t\ter => { postMessage([e.data[0], 1, '' + er]); }\n\t\t);\n\t});\n\tconst workerURL = URL.createObjectURL(new Blob([script]));\n\t// Create an \"inline\" worker (1:1 at definition time)\n\tconst worker = new Worker(workerURL);\n\n\t/** Handle RPC results/errors coming back out of the worker.\n\t *  Messages coming from the worker take the form `[id, status, result]`:\n\t *    id     - counter-based unique ID for the RPC call\n\t *    status - 0 for success, 1 for failure\n\t *    result - the result or error, depending on `status`\n\t */\n\tworker.onmessage = e => {\n\t\t// invoke the promise's resolve() or reject() depending on whether there was an error.\n\t\tpromises[e.data[0]][e.data[1]](e.data[2]);\n\n\t\t// ... then delete the promise controller\n\t\tpromises[e.data[0]] = null;\n\t};\n\n\t// Return a proxy function that forwards calls to the worker & returns a promise for the result.\n\treturn function (args) {\n\t\targs = [].slice.call(arguments);\n\t\treturn new Promise(function () {\n\t\t\t// Add the promise controller to the registry\n\t\t\tpromises[++currentId] = arguments;\n\n\t\t\t// Send an RPC call to the worker - call(id, params)\n\t\t\t// The filter is to provide a list of transferables to send zero-copy\n\t\t\tworker.postMessage([currentId, args], args.filter(x => (\n\t\t\t\t(x instanceof ArrayBuffer) ||\n\t\t\t\t(x instanceof MessagePort) ||\n\t\t\t\t(self.ImageBitmap && x instanceof ImageBitmap)\n\t\t\t)));\n\t\t});\n\t};\n}\n"],"names":["asyncFunction","let","currentId","promises","workerURL","URL","createObjectURL","Blob","e","Promise","resolve","data","then","v","$$","apply","d","postMessage","filter","x","ArrayBuffer","MessagePort","self","ImageBitmap","er","worker","Worker","onmessage","args","slice","call","arguments"],"mappings":"eAIe,SAAkBA,GAEhCC,IAAIC,EAAY,EAGVC,KAuBAC,EAAYC,IAAIC,gBAAgB,IAAIC,MApB3B,MAAMP,EAAc,uBAAeQ,GAIjDC,QAAQC,QAAQF,EAAEG,KAAK,IAAIC,cAC1BC,UAAKC,GAAGC,MAAMD,GAAID,KACjBD,cAGDI,GACCC,aAAaT,EAAEG,KAAK,GAAI,EAAGK,IAAKA,GAAGE,gBAAOC,UACxCA,aAAaC,aACbD,aAAaE,aACbC,KAAKC,aAAeJ,aAAaI,yBAIpCC,GAAQP,aAAaT,EAAEG,KAAK,GAAI,EAAG,GAAKa,UAKpCC,EAAS,IAAIC,OAAOtB,GAiB1B,OATAqB,EAAOE,mBAAYnB,GAElBL,EAASK,EAAEG,KAAK,IAAIH,EAAEG,KAAK,IAAIH,EAAEG,KAAK,IAGtCR,EAASK,EAAEG,KAAK,IAAM,MAIhB,SAAUiB,GAEhB,OADAA,KAAUC,MAAMC,KAAKC,WACd,IAAItB,QAAQ,WAElBN,IAAWD,GAAa6B,UAIxBN,EAAOR,aAAaf,EAAW0B,GAAOA,EAAKV,gBAAOC,UAChDA,aAAaC,aACbD,aAAaE,aACbC,KAAKC,aAAeJ,aAAaI"}